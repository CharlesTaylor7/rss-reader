<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" xmlns:media="http://search.yahoo.com/mrss/"
	>

<channel>
	<title>Manuel Cerón</title>
	<atom:link href="https://ceronman.com/feed/" rel="self" type="application/rss+xml" />
	<link>https://ceronman.com</link>
	<description>A blog mostly about programming languages</description>
	<lastBuildDate>Tue, 28 May 2024 17:19:28 +0000</lastBuildDate>
	<language>en</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>http://wordpress.com/</generator>

<image>
	<url>https://ceronman.com/wp-content/uploads/2020/09/cropped-gux89dnhovfhs6g7hngi-yi8fr3l6zixrkywebzvgw4.png?w=32</url>
	<title>Manuel Cerón</title>
	<link>https://ceronman.com</link>
	<width>32</width>
	<height>32</height>
</image> 
<cloud domain='ceronman.com' port='80' path='/?rsscloud=notify' registerProcedure='' protocol='http-post' />
<atom:link rel="search" type="application/opensearchdescription+xml" href="https://ceronman.com/osd.xml" title="Manuel Cerón" />
	<atom:link rel='hub' href='https://ceronman.com/?pushpress=hub'/>
	<item>
		<title>Types and self-documenting code in Rust</title>
		<link>https://ceronman.com/2024/05/28/types-and-self-documenting-code-in-rust/</link>
		
		<dc:creator><![CDATA[ceronman]]></dc:creator>
		<pubDate>Tue, 28 May 2024 17:19:28 +0000</pubDate>
				<category><![CDATA[Uncategorized]]></category>
		<category><![CDATA[c]]></category>
		<category><![CDATA[coding]]></category>
		<category><![CDATA[languages]]></category>
		<category><![CDATA[programming]]></category>
		<category><![CDATA[Rust]]></category>
		<guid isPermaLink="false">http://ceronman.com/?p=652</guid>

					<description><![CDATA[During the past months, I’ve been lucky to have the chance to write more Rust code for work and also for fun. Rust continues to be an interesting and fun language for me. Not everything is perfect, of course. Today I wanted to write about something that has bothered me since day one. It’s definitely &#8230; <a href="https://ceronman.com/2024/05/28/types-and-self-documenting-code-in-rust/" class="more-link">Continue reading <span class="screen-reader-text">Types and self-documenting code in&#160;Rust</span> <span class="meta-nav">&#8594;</span></a>]]></description>
										<content:encoded><![CDATA[
<p>During the past months, I’ve been lucky to have the chance to write more Rust code for work and also for fun. Rust continues to be an interesting and fun language for me. Not everything is perfect, of course. Today I wanted to write about something that has bothered me since day one. It’s definitely not a huge problem, more like a slight annoyance, but I wanted to write about it anyway because it relates to the design of the Rust language and its standard library, which is a topic that I find interesting. So here it goes:</p>



<p>There are tons of methods in the standard library that return concrete types instead of abstractions (i.e. traits). These typically have the same name as the method itself, just with different casing. This often makes the signature of methods less intuitive. </p>



<p>Let’s take a look at an example. Strings have a method called <code>chars()</code>. This method has the following signature:</p>



<!-- HTML generated using hilite.me --><div style="background: #ffffff;overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em"><pre style="margin: 0;line-height: 125%"><span style="color: #0000aa">pub</span> <span style="color: #0000aa">fn</span> chars(&amp;self) -&gt; Chars&lt;&#039;_&gt;
</pre></div>



<p>Ok, so <code>chars()</code> returns <code>Chars</code>, that doesn’t tell me much. It sounds like I’m getting the characters of the string, but I have no idea if it’s an array, a slice, an iterator, or something else. Let’s look at the documentation of the function:</p>



<blockquote class="wp-block-quote is-style-plain is-layout-flow wp-block-quote-is-layout-flow">
<p>Returns an <strong>iterator</strong> over the chars of a string slice.</p>



<p>As a string slice consists of valid UTF-8, we can iterate through a string slice by char. This method returns such an iterator.</p>



<p>It&#8217;s important to remember that char represents a Unicode Scalar Value, and might not match your idea of what a &#8216;character&#8217; is. Iteration over grapheme clusters may be what you actually want. This functionality is not provided by Rust&#8217;s standard library, check crates. io instead.</p>
</blockquote>



<p>Alright, not a big problem, isn&#8217;t it? Well, it still bothers me a little bit. The reason is that one of the advantages of adding type annotations in statically typed languages is supposedly that it makes the code more self-documenting. The signature should allow us to have an idea of what the function or method does without requiring extra documentation.</p>



<p>Consider for a moment that the signature of this function was something like this instead:</p>



<!-- HTML generated using hilite.me --><div style="background: #ffffff;overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em"><pre style="margin: 0;line-height: 125%"><span style="color: #0000aa">pub</span> <span style="color: #0000aa">fn</span> chars(&amp;self) -&gt; <span style="color: #0000aa">impl</span> Iterator&lt;Item=char&gt;
</pre></div>



<p>We can argue that this is more self-documenting than the previous signature. It’s easier to understand what the function does just by looking at it. We still need the documentation for certain details, for example, the fact that this iterates over Unicode scalars and not grapheme clusters, but I’d argue that even this is obvious from the signature.</p>



<p>Why are self-documenting signatures important? Well, it’s very common to learn APIs directly while coding and looking at the completion suggestions. For example, in VS Code, this is what we get in completion:</p>



<figure class="wp-block-image size-large"><a href="https://ceronman.com/wp-content/uploads/2024/05/screenshot-2024-05-25-at-6.02.17e280afpm.png"><img width="1024" height="541" data-attachment-id="676" data-permalink="https://ceronman.com/2024/05/28/types-and-self-documenting-code-in-rust/screenshot-2024-05-25-at-6-02-17e280afpm/" data-orig-file="https://ceronman.com/wp-content/uploads/2024/05/screenshot-2024-05-25-at-6.02.17e280afpm.png" data-orig-size="1350,714" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="screenshot-2024-05-25-at-6.02.17e280afpm" data-image-description="" data-image-caption="" data-medium-file="https://ceronman.com/wp-content/uploads/2024/05/screenshot-2024-05-25-at-6.02.17e280afpm.png?w=300" data-large-file="https://ceronman.com/wp-content/uploads/2024/05/screenshot-2024-05-25-at-6.02.17e280afpm.png?w=1024" src="https://ceronman.com/wp-content/uploads/2024/05/screenshot-2024-05-25-at-6.02.17e280afpm.png?w=1024" alt="" class="wp-image-676" /></a></figure>



<p>We only have signatures here and <code>Chars</code> doesn’t tell us much.</p>



<p>RustRover does a slightly better job here, showing us the documentation for the selected option:</p>



<figure class="wp-block-image size-large"><a href="https://ceronman.com/wp-content/uploads/2024/05/screenshot-2024-05-24-at-4.37.42e280afpm.png"><img width="1024" height="399" data-attachment-id="678" data-permalink="https://ceronman.com/2024/05/28/types-and-self-documenting-code-in-rust/screenshot-2024-05-24-at-4-37-42e280afpm/" data-orig-file="https://ceronman.com/wp-content/uploads/2024/05/screenshot-2024-05-24-at-4.37.42e280afpm.png" data-orig-size="2248,876" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="screenshot-2024-05-24-at-4.37.42e280afpm" data-image-description="" data-image-caption="" data-medium-file="https://ceronman.com/wp-content/uploads/2024/05/screenshot-2024-05-24-at-4.37.42e280afpm.png?w=300" data-large-file="https://ceronman.com/wp-content/uploads/2024/05/screenshot-2024-05-24-at-4.37.42e280afpm.png?w=1024" src="https://ceronman.com/wp-content/uploads/2024/05/screenshot-2024-05-24-at-4.37.42e280afpm.png?w=1024" alt="" class="wp-image-678" /></a></figure>



<p>Better, but only partially useful.<br><br>I was wondering what is the reason behind returning concrete types in Rust’s standard library instead of abstractions. In terms of best practices, different programming language communities have different opinions. In Java, the most accepted position is to accept and return abstractions in APIs as much as possible. But in the Go community, the suggested practice is to <a href="https://go.dev/doc/effective_go#interfaces">accept interfaces but return structs</a>.</p>



<p>I prefer the idea of returning abstractions when those already exist. This not only makes the code more self-documenting, but it also gives the flexibility to eventually change the implementation without breaking the API. It also reduces the API surface as we don’t have to expose an extra type.</p>



<p>It’s possible that all these methods existed way before Rust could specify abstractions as return types of functions efficiently. Return position impl traits (RPIT) were only <a href="https://blog.rust-lang.org/2018/05/10/Rust-1.26.html#impl-trait">introduced in Rust 1.26</a>. Before that, the only way to do something similar required <code>Box&lt;dyn Trait&gt;</code> which would add some costs in the form of allocations and dynamic dispatch.</p>



<p>But that’s not the whole story. The actual reason is that <code>Chars</code> is much more than just <code>Iterator&lt;Item=char&gt;</code>. If we look at the source code, we see that <code>Chars</code> not only implements that, but also <code>DoubleEndedIterator</code>, <code>FusedIterator</code> and <code>Debug</code>.<br><br>Perhaps we could still have a signature like this:</p>



<!-- HTML generated using hilite.me --><div style="background: #ffffff;overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em"><pre style="margin: 0;line-height: 125%"><span style="color: #0000aa">fn</span> chars(s: &amp;<span style="color: #0000aa">str</span>) -&gt; <span style="color: #0000aa">impl</span> DoubleEndedIterator&lt;Item=char&gt; 
                        + FusedIterator 
                        + Debug
</pre></div>



<p>Yes, it’s more self-documenting, but it starts to get big and noisy. It likely won’t fit in a completion dialog anymore.&nbsp;</p>



<p>But even this would not work, because <code>Chars</code> also has an <a href="https://doc.rust-lang.org/src/core/str/iter.rs.html#141">inherent implementation</a> that provides the <code>as_str()</code> method. So I guess that there is no choice but to use a concrete type in this case.</p>



<p>If we have no choice but to use a concrete type, is there any way to make this a little bit more intuitive to use? I think naming would have helped a lot here. Had <code>Chars</code> been named <code>CharIterator</code> instead, this signature would have been more intuitive. As we all know, <a href="https://martinfowler.com/bliki/TwoHardThings.html">naming is definitely one of the hardest things in computer science</a>. But there are also cases where naming is not going to be enough to make a signature alone self-documenting.</p>



<p>We could argue that having self-documenting code doesn’t necessarily imply that everything should be immediately obvious just from the signature. After all, names are labels that we put on things, and as long as we can look at the definition of those names, our code is going to be self-documenting. In fact, when I’m learning a new Rust API, this is what I do, I find a type with a name I don’t understand, and I go to the definition to learn what it is.</p>



<p>And this brings me to my next pain point when learning Rust APIs: If I find a name that I don’t understand (like <code>Chars</code>) and I jump to its definition, I often find something like this:</p>



<!-- HTML generated using hilite.me --><div style="background: #ffffff;overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em"><pre style="margin: 0;line-height: 125%"><span style="color: #0000aa">pub</span> <span style="color: #0000aa">struct</span> Chars&lt;&#039;a&gt; {
    <span style="color: #0000aa">pub</span>(super) iter: slice::Iter&lt;&#039;a, <span style="color: #0000aa">u8</span>&gt;,
}
</pre></div>



<p>I see a struct definition with a non-public field (yes, even when the field has a <code>pub</code> keyword, it doesn’t mean it’s public, but I would need another post to talk about visibility modifiers in Rust). This definition doesn’t tell me what <code>Chars</code> can do, or in other words, what traits are implemented for this. In particular, it doesn’t tell me that <code>Chars</code> is an <code>Iterator&lt;Item=char&gt;</code>. The way the trait system works is that traits can be implemented <a href="https://doc.rust-lang.org/reference/items/implementations.html#orphan-rules">almost</a> everywhere. So the trait implementations are scattered across the code.<br><br>In some other languages, it’s easier to recognize what interfaces a type implements. For example, in C#, there is a method of <code>string</code> called <code>GetEnumerator()</code>. It’s very similar to <code>chars()</code> in Rust. The signature looks like this:</p>



<!-- HTML generated using hilite.me --><div style="background: #ffffff;overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em"><pre style="margin: 0;line-height: 125%"><span style="color: #0000aa">public</span> CharEnumerator <span style="color: #00aa00">GetEnumerator</span> ()
</pre></div>



<p>The first thing to notice is that they also have a concrete type as return. However, their naming is slightly better, it’s clear that this type is an <code>Enumerator</code> (which is the way C# calls Iterators). Now if we go to the definition of <code>CharEnumerator</code>, we get this:</p>



<!-- HTML generated using hilite.me --><div style="background: #ffffff;overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em"><pre style="margin: 0;line-height: 125%"><span style="color: #0000aa">public</span> <span style="color: #0000aa">sealed</span> <span style="color: #0000aa">class</span> <span style="color: #00aa00;text-decoration: underline">CharEnumerator</span> : 
    IEnumerator, IEnumerator&lt;<span style="color: #00aaaa">char</span>&gt;, IDisposable, ICloneable 
{ 
    ... 
}
</pre></div>



<p>The definition of the concrete type explicitly states which interfaces it implements. We don’t need to search through the code to figure out what <code>CharEnumerator</code> is.<br><br>Now, don’t get me wrong, I really like Rust’s trait system. I think it’s very elegant and it has a lot of advantages over more restrictive systems such as the one in C#. But there is no doubt that one of the disadvantages of this flexibility is that it affects the self-documenting property of the type system.</p>



<p>So, back to Rust, how can we know what <code>Chars</code> is? One option is looking at the <a href="https://doc.rust-lang.org/std/str/struct.Chars.html">documentation</a>, which includes a convenient list of traits implemented by this type. But again, this list is incomplete, because new traits and implementation could be added by the user crate of the type.</p>



<p>IDEs can definitely help here. RustRover shows an icon next to the struct definition listing the implementations for this type:</p>



<figure class="wp-block-image size-large"><a href="https://ceronman.com/wp-content/uploads/2024/05/screenshot-2024-05-27-at-2.48.28e280afpm.png"><img width="1024" height="455" data-attachment-id="679" data-permalink="https://ceronman.com/2024/05/28/types-and-self-documenting-code-in-rust/screenshot-2024-05-27-at-2-48-28e280afpm/" data-orig-file="https://ceronman.com/wp-content/uploads/2024/05/screenshot-2024-05-27-at-2.48.28e280afpm.png" data-orig-size="1290,574" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="screenshot-2024-05-27-at-2.48.28e280afpm" data-image-description="" data-image-caption="" data-medium-file="https://ceronman.com/wp-content/uploads/2024/05/screenshot-2024-05-27-at-2.48.28e280afpm.png?w=300" data-large-file="https://ceronman.com/wp-content/uploads/2024/05/screenshot-2024-05-27-at-2.48.28e280afpm.png?w=1024" src="https://ceronman.com/wp-content/uploads/2024/05/screenshot-2024-05-27-at-2.48.28e280afpm.png?w=1024" alt="" class="wp-image-679" /></a></figure>



<p>VS Code also shows an implementations lens right above the struct definition, although it’s quite less readable, in my opinion:</p>



<figure class="wp-block-image size-large"><a href="https://ceronman.com/wp-content/uploads/2024/05/screenshot-2024-05-27-at-2.50.58e280afpm.png"><img loading="lazy" width="1024" height="503" data-attachment-id="681" data-permalink="https://ceronman.com/2024/05/28/types-and-self-documenting-code-in-rust/screenshot-2024-05-27-at-2-50-58e280afpm/" data-orig-file="https://ceronman.com/wp-content/uploads/2024/05/screenshot-2024-05-27-at-2.50.58e280afpm.png" data-orig-size="2422,1190" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="screenshot-2024-05-27-at-2.50.58e280afpm" data-image-description="" data-image-caption="" data-medium-file="https://ceronman.com/wp-content/uploads/2024/05/screenshot-2024-05-27-at-2.50.58e280afpm.png?w=300" data-large-file="https://ceronman.com/wp-content/uploads/2024/05/screenshot-2024-05-27-at-2.50.58e280afpm.png?w=1024" src="https://ceronman.com/wp-content/uploads/2024/05/screenshot-2024-05-27-at-2.50.58e280afpm.png?w=1024" alt="" class="wp-image-681" /></a></figure>



<p>Both IDEs are missing a bunch of <a href="https://stackoverflow.com/questions/73861891/what-are-blanket-implementations-in-rust">blanket implementations</a>. For example, the fact that <code>Chars</code> implements <code>IntoIterator</code> because <code>IntoIterator</code> is implemented for every <code>Iterator</code>.</p>



<p>All this can be slightly worse in some cases. Let’s look at another example of the standard library. The <code>split</code> method of strings. The signature is:</p>



<!-- HTML generated using hilite.me --><div style="background: #ffffff;overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em"><pre style="margin: 0;line-height: 125%"><span style="color: #0000aa">pub</span> <span style="color: #0000aa">fn</span> split&lt;&#039;a, P: Pattern&lt;&#039;a&gt;&gt;(&amp;&#039;a self, pat: P) -&gt; Split&lt;&#039;a, P&gt;
</pre></div>



<p>Again we have a return type named as the method, but this time, when trying to go to the definition we find this:</p>



<!-- HTML generated using hilite.me --><div style="background: #ffffff;overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em"><pre style="margin: 0;line-height: 125%">generate_pattern_iterators! {
    forward:
        <span style="color: #aaaaaa;font-style: italic">/// Created with the method [`split`].</span>
        <span style="color: #aaaaaa;font-style: italic">///</span>
        <span style="color: #aaaaaa;font-style: italic">/// [`split`]: str::split</span>
        <span style="color: #0000aa">struct</span> Split;
    reverse:
        <span style="color: #aaaaaa;font-style: italic">/// Created with the method [`rsplit`].</span>
        <span style="color: #aaaaaa;font-style: italic">///</span>
        <span style="color: #aaaaaa;font-style: italic">/// [`rsplit`]: str::rsplit</span>
        <span style="color: #0000aa">struct</span> RSplit;
    stability:
        <span style="color: #4c8317">#[stable(feature = </span><span style="color: #aa5500">&quot;rust1&quot;</span><span style="color: #4c8317">, since = </span><span style="color: #aa5500">&quot;1.0.0&quot;</span><span style="color: #4c8317">)]</span>
    internal:
        SplitInternal yielding (&amp;&#039;a <span style="color: #0000aa">str</span>);
    delegate double ended;
}
</pre></div>



<p>The <code>Split</code> struct is not written directly, but it is actually generated by a macro, which also generates a bunch of implementations for it. Types and implementations that are generated by macros is another common theme in the Rust standard library. Of course you can go and read the macro definition, but I find reading Rust’s declarative macros not very pleasant.</p>



<p>IDEs can help us again by showing us the expansion of the macro. RustRover is even smart enough to show us the implementations list of the struct from the un expanded macro:</p>



<figure class="wp-block-image size-large"><a href="https://ceronman.com/wp-content/uploads/2024/05/screenshot-2024-05-27-at-3.10.13e280afpm.png"><img loading="lazy" width="1024" height="517" data-attachment-id="682" data-permalink="https://ceronman.com/2024/05/28/types-and-self-documenting-code-in-rust/screenshot-2024-05-27-at-3-10-13e280afpm/" data-orig-file="https://ceronman.com/wp-content/uploads/2024/05/screenshot-2024-05-27-at-3.10.13e280afpm.png" data-orig-size="1424,720" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="screenshot-2024-05-27-at-3.10.13e280afpm" data-image-description="" data-image-caption="" data-medium-file="https://ceronman.com/wp-content/uploads/2024/05/screenshot-2024-05-27-at-3.10.13e280afpm.png?w=300" data-large-file="https://ceronman.com/wp-content/uploads/2024/05/screenshot-2024-05-27-at-3.10.13e280afpm.png?w=1024" src="https://ceronman.com/wp-content/uploads/2024/05/screenshot-2024-05-27-at-3.10.13e280afpm.png?w=1024" alt="" class="wp-image-682" /></a></figure>



<p>But it’s undeniable that macro generated types hurt the self-documenting property of the type system as well.</p>



<p>Is there any way to improve things? I don’t want Rust to change its trait system or lose macros. These are great and powerful features, even if they have some drawbacks. Besides my previous suggestion of improving naming, which I think goes a long way,  IDEs can help a lot too. They could have an easy way of showing all the implemented traits of a given type, including blanket ones. This could be shown while hovering a type, but also in documentation pop ups for signatures. Perhaps there is also a way of showing some compact trait information in the signatures of completion items.</p>



<p>Finally, perhaps it&#8217;s possible to show a summary of what types and impls a macro call generates. Maybe even for derive macros as well. When a language&#8217;s type system is so flexible, and there are so many tools for meta-programming, the help of the IDEs becomes extremely valuable. RustRover and VS Code + Rust Analyzer already do some useful things, but I think they are still in their infancy.  I&#8217;m looking forward for these IDEs to mature and improve the coding experience for Rust.</p>
]]></content:encoded>
					
		
		
		
		<media:content url="https://2.gravatar.com/avatar/8446d2ad9b9d7eb75d269da1966fd480dda55da09158a64d1779445af3a58b5b?s=96&#38;d=https%3A%2F%2Fs0.wp.com%2Fi%2Fmu.gif&#38;r=G" medium="image">
			<media:title type="html">ceronman</media:title>
		</media:content>

		<media:content url="https://ceronman.com/wp-content/uploads/2024/05/screenshot-2024-05-25-at-6.02.17e280afpm.png?w=1024" medium="image" />

		<media:content url="https://ceronman.com/wp-content/uploads/2024/05/screenshot-2024-05-24-at-4.37.42e280afpm.png?w=1024" medium="image" />

		<media:content url="https://ceronman.com/wp-content/uploads/2024/05/screenshot-2024-05-27-at-2.48.28e280afpm.png?w=1024" medium="image" />

		<media:content url="https://ceronman.com/wp-content/uploads/2024/05/screenshot-2024-05-27-at-2.50.58e280afpm.png?w=1024" medium="image" />

		<media:content url="https://ceronman.com/wp-content/uploads/2024/05/screenshot-2024-05-27-at-3.10.13e280afpm.png?w=1024" medium="image" />
	</item>
		<item>
		<title>My experience crafting an interpreter with Rust</title>
		<link>https://ceronman.com/2021/07/22/my-experience-crafting-an-interpreter-with-rust/</link>
					<comments>https://ceronman.com/2021/07/22/my-experience-crafting-an-interpreter-with-rust/#comments</comments>
		
		<dc:creator><![CDATA[ceronman]]></dc:creator>
		<pubDate>Thu, 22 Jul 2021 17:33:19 +0000</pubDate>
				<category><![CDATA[Uncategorized]]></category>
		<guid isPermaLink="false">http://ceronman.com/?p=572</guid>

					<description><![CDATA[Last year I finally decided to learn some Rust. The official book by Steve Klabnik and Carol Nichols is excellent, but even after reading it and working on some small code exercises, I felt that I needed more to really understand the language. I wanted to work on a small project to get some hands-on &#8230; <a href="https://ceronman.com/2021/07/22/my-experience-crafting-an-interpreter-with-rust/" class="more-link">Continue reading <span class="screen-reader-text">My experience crafting an interpreter with&#160;Rust</span> <span class="meta-nav">&#8594;</span></a>]]></description>
										<content:encoded><![CDATA[
<p>Last year I finally decided to learn some Rust. The <a href="https://doc.rust-lang.org/book/">official book </a>by Steve Klabnik and Carol Nichols is excellent, but even after reading it and working on some small code exercises, I felt that I needed more to really understand the language. I wanted to work on a small project to get some hands-on experience, but most of my ideas didn&#8217;t feel very well suited for Rust.</p>



<p>Then I started reading the amazing book <a href="https://craftinginterpreters.com/">Crafting Interpreters</a> by Bob Nystrom. As the name suggests, the book is about writing an interpreter for a dynamic language named Lox. The book is split into two parts: the first one shows how to implement a simple tree-walking interpreter using Java. The second part shows how to implement the same interpreter, but this time using a high-performance bytecode VM using C. I implemented<a href="https://github.com/ceronman/cloxure"> the first part in Clojure</a>, and then I realized that the second part was the perfect project for trying Rust.</p>



<p>The domain of language VMs seems to be almost entirely dominated by C/C++.&nbsp; VMs are very performance sensitive and often require a lot of micro-optimization. This project seemed like a perfect exercise to compare Rust against these languages. I was especially interested in checking if Rust could match the same speed while providing better safety and ergonomics.</p>



<p><em>Disclaimer: It&#8217;s been a long time since I used C/C++, probably more than 15 years. Even then, I mostly used these languages for university projects or some open source contributions. During my entire professional career, I have only used higher-level languages. Consider this post as coming from a beginner.</em></p>



<p>Now, matching the speed of the C version of the Lox interpreter (<em>clox</em>) is no easy feat. While many books on the topic of compilers and interpreters focus exclusively on explaining the algorithms and leave performance as an afterthought, Crafting Interpreters shows how to implement a really fast interpreter. For example, in some simple benchmarks, it is common to observe that <em>clox</em> is 2x or even 3x faster than equivalent Python or Perl code.</p>



<p><em>Side note: Take this comparison with a grain of salt. The reason Python and Perl are slower is that these languages provide more flexibility and that comes with a performance cost. This is better explained in </em><a href="https://wren.io/performance.html"><em>Wren’s web page</em></a><em>, which is another language by the same author whose interpreter inspired clox. So yes, the comparison with Python and Perl is a bit oranges and apples, but the main point here is that clox performance is really good and very production-ready.</em></p>



<h2 class="wp-block-heading">Using only safe code</h2>



<p>When I began coding my Rust implementation of Lox, I decided to stick to purely safe code. Rust’s main selling point is its safety, but of course you have to stick to the safe part of the language. Rust also allows you to use unsafe code, and if you do that, I think there is no blocker to match the speed of C, although that also means matching its unsafety. It made sense to stick to safe code to begin with.</p>



<p>I also decided to take advantage of Rust standard library as much as possible. One more interesting fact about <em>Crafting Interpreters</em> is that it does everything from scratch. The book doesn’t use libraries or parser generators or any tool besides a C compiler and standard library (which is pretty bare-bones). Every single line of code is in the book and I find this absolutely amazing. So there are some chapters dedicated to showing how to write dynamic arrays, strings, and hash maps. Given that Rust’s standard library already has those and they are very optimized, I decided to use them and skip a custom implementation. Besides, implementing those manually most likely requires writing unsafe code.</p>



<p>I also wanted to take advantage of Rust’s advanced type system as much as possible. The <em>clox</em> implementation uses variable-length opcodes where most of them use one byte but some use adjacent bytes to pack parameters or data. In my implementation, I decided to use fixed-length opcodes using an <code>enum</code>. Rust’s sum types are a delight to use because the compiler always has your back and warns you if you ever forget to check for a specific case. I consider this a huge advance in ergonomics.</p>



<p>The beginning of writing the lox interpreter in Rust was a breeze. The compiler in particular was a joy to write. Rust felt much nicer to write than the old and quirky C. The initial parts of the VM were also really nice to write thanks to sum types, compile-time checks, and a ready-to-use standard library. However, things started to get very tricky once I worked on more advanced stuff such as closures and classes. The <em>clox</em> implementation uses pointers and aliasing very liberally, while Rust’s aliasing rules are very strict and the borrow checker disallows many patterns to ensure safety. Because of this, I spent a ton of time finding workarounds to make the borrow checker happy.</p>



<p><em>Side note: Dealing with the borrow checker is a well-known struggle for Rust beginners. This was the reason why I spent so much time here. The rules are simple but for some reason, it’s really hard to keep track of them in a big system. I would often write huge refactorings thinking that they would be a solution to a borrow checker error, just to get another one at the end of the refactoring. This happens less frequently the more experience I get with the language, but it still happens. The book </em><a href="https://rust-unofficial.github.io/too-many-lists/"><em>Learn Rust With Entirely Too Many Linked Lists</em></a><em>&nbsp; has some good examples of how brutally complex the borrow checker can be.</em></p>



<h2 class="wp-block-heading">A garbage collector in safe Rust</h2>



<p>By far the hardest part to implement in my safe Rust implementation of Lox was the garbage collector. How do you even write a GC without manual memory allocation and deallocation? I spent quite some time experimenting and trying different approaches.</p>



<p>One quick idea that crossed my mind was that perhaps I could skip the GC completely. If Rust can be memory safe without GC, perhaps I could use the same mechanisms to do the same for Lox. For example, using reference counted smart pointers. But I quickly discarded this idea. The Lox language doesn’t have the strict rules that Rust has; it’s easy to create cyclic data structures that would leak memory if implemented using reference counting. A GC is a must here.</p>



<p>So I got an idea from a<a href="https://www.youtube.com/watch?v=aKLntZcp27M&amp;t=1960s"> very interesting talk at RustConf 2018 by Catherine West</a>. A common workaround in the Rust world to deal with graph-like structures with cycles is to use vector indices as some sort of pointer. I decided to study the code of some popular crates such as <a href="http://id-arena">id-arena</a> and <a href="https://crates.io/crates/typed-arena">typed-arena</a> that use this concept in some way. But the main issue with <em>id-arena</em> is that it doesn&#8217;t support deletion of individual objects because there is the risk of running into <a href="https://en.wikipedia.org/wiki/ABA_problem">the ABA problem</a>. This happens when you delete an object and later reuse its slot while there is a live reference somewhere, which will then be pointed to the wrong place in the vector. There are ways to solve this issue, such as using a <a href="https://crates.io/crates/generational-arena">generational arena</a>, but this felt like over-complicating things.</p>



<p>One day I realized something that now feels so obvious that I’m almost ashamed to admit it: I am writing a garbage collector and its main job is to find objects with no references from the live parts of the program. This means that, if my GC works correctly, I should not worry about the ABA problem at all, because the GC would ensure that there will be no live references of the freed objects.</p>



<p>With this idea in mind, I ended up with a very simple design for a GC in safe Rust. It’s basically a vector of trait objects. Every object should implement a trait (<code>GcTrace</code>), which has methods for tracing an object. Additionally, there is a second vector that contains <em>tombstones</em> to keep track of the deleted objects. The allocation of an object means adding it to the vector and returning the index which will act as some sort of pointer. Freeing an object means swapping it out of the vector and putting some placeholder instead, and adding the index to the list of tombstones that will be reused in a future allocation.</p>



<p>Instead of returning plain integers, I also created a generic wrapper struct to get some type safety, so that if I allocate objects of different types, the result index is also of a different type. This is very similar to what the <em>id-arena</em> crate does. This result index is <a href="https://doc.rust-lang.org/std/marker/trait.Copy.html">Copy</a>, which means that I can pass it around as I want without getting nagged by the borrow checker. This also facilitated the design of the interpreter quite a lot, as I was able to get rid of many workarounds that I added to please the borrow checker such as using <a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html">RefCell</a> and <a href="https://doc.rust-lang.org/std/rc/struct.Rc.html">Rc</a>. In the end, using the GC looks like this:</p>



<!-- HTML generated using hilite.me --><div style="background:#ffffff;overflow:auto;width:auto;background:#ffffff;width:auto;border:solid gray;border-width:0.1em 0.1em 0.1em 0.8em;padding:0.1em;"><pre style="margin:0;line-height:125%;"><span style="color:#008000;">// creates an object</span>
<span style="color:#0000ff;">let</span> closure: GcRef&lt;Closure&gt; = gc.alloc(Closure { <span style="color:#008000;">/*…*/</span> }); 
</pre></div>



<p>Then I can copy and pass around this closure reference everywhere, but when I actually need to do something with the object, I can borrow it from the garbage collector. For example:</p>



<!-- HTML generated using hilite.me --><div style="background:#ffffff;overflow:auto;width:auto;background:#ffffff;width:auto;border:solid gray;border-width:0.1em 0.1em 0.1em 0.8em;padding:0.1em;"><pre style="margin:0;line-height:125%;"><span style="color:#0000ff;">let</span> upvalues = gc.deref(closure).upvalues;
</pre></div>



<p>This de-reference dance is a bit unergonomic. I have to call <code>gc.deref()</code> every time I want to work with any GC object. I thought that perhaps I could implement <a href="https://doc.rust-lang.org/std/ops/trait.Deref.html">Deref</a> and make the Rust compiler do it automatically for me, but this would require each <code>GcRef</code> object to hold a reference to the GC and dealing with the lifetimes would be a nightmare. I could also make the GC completely static, but I don’t even know how to do that with safe Rust only, so I decided to just live with it.</p>



<p>This GC design is extremely simple and it has a bunch of shortcomings. One of them is the fact that the memory needed for the vector of trait objects and the tombstones never shrinks. So if a program suddenly allocates a lot of objects and those are then freed by the GC, the space required for the slots remains there forever. Another shortcoming has to do with when to run the collection process. The GC in <em>clox</em> has precise control of every allocation, and there is a count of the number of the total bytes allocated. When this count reaches some threshold, the collection process runs. In my Rust GC, I can’t have a precise count of the number of bytes allocated because objects often have dynamically sized fields such as strings or vectors. As a workaround, I added a <code>size()</code> method to the <code>GcTrace</code> trait to estimate the size of an object and use it to keep count of the allocated bytes. But this is just an approximation.</p>



<p>Once I was done with the GC, the remaining parts of the Lox interpreter were easy to write. I ended up with a <a href="https://github.com/ceronman/loxido">Lox implementation written in 100% safe Rust</a> code and passing the 243 tests from the Lox integration test suite.</p>



<h2 class="wp-block-heading">Performance</h2>



<p>After having a working Lox interpreter and a green test suite to validate any change, it was time to start working on improving performance. At this point I had already abandoned any hope of matching the speed of <em>clox</em> with only safe Rust. As I mentioned before, <em>clox</em> is a really fast implementation and it uses all sorts of tricks to achieve this. From using pointer arithmetic without any runtime checks to the super tricky <a href="https://brionv.com/log/2018/05/17/javascript-engine-internals-nan-boxing/">NaN boxing</a>. However, I thought that if I added a few unsafe blocks to my code base, I could at least come close to the speed of <em>clox</em>.</p>



<p>The first step is, of course, measuring the performance. I decided to use the <a href="https://github.com/munificent/craftinginterpreters/tree/master/test/benchmark">same benchmark programs available in the crafting interpreters repository</a>. This way of measuring might not be the best, but it’s good enough for a language without any real-world programs. I also decided to manually transpile the benchmark programs to Python and Perl to have some point of comparison. I was expecting some bad results for my very first implementation, but they were much worse than I anticipated:</p>



<figure class="wp-block-image size-large"><a href="https://ceronman.com/wp-content/uploads/2021/07/image-2.png"><img loading="lazy" width="884" height="1024" data-attachment-id="590" data-permalink="https://ceronman.com/image-2/" data-orig-file="https://ceronman.com/wp-content/uploads/2021/07/image-2.png" data-orig-size="1742,2018" data-comments-opened="0" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="image-2" data-image-description="" data-image-caption="" data-medium-file="https://ceronman.com/wp-content/uploads/2021/07/image-2.png?w=259" data-large-file="https://ceronman.com/wp-content/uploads/2021/07/image-2.png?w=884" src="https://ceronman.com/wp-content/uploads/2021/07/image-2.png?w=884" alt="" class="wp-image-590" srcset="https://ceronman.com/wp-content/uploads/2021/07/image-2.png?w=884 884w, https://ceronman.com/wp-content/uploads/2021/07/image-2.png?w=129 129w, https://ceronman.com/wp-content/uploads/2021/07/image-2.png?w=259 259w, https://ceronman.com/wp-content/uploads/2021/07/image-2.png?w=768 768w, https://ceronman.com/wp-content/uploads/2021/07/image-2.png 1742w" sizes="(max-width: 884px) 100vw, 884px" /></a></figure>



<p>Not only is <em><a href="https://github.com/ceronman/loxido">Loxido</a></em> (my implementation) often several times slower than <em>clox</em>, but, in many cases, it’s even slower than <em>jlox</em> (the tree walking implementations written in Java)! After the initial shock, I realized that there was no other way than to start profiling and shave those times as much as possible.</p>



<p>The very first run of <a href="https://perf.wiki.kernel.org/index.php/Main_Page">perf</a> showed me a clear target to blame for my poor performance:</p>



<figure class="wp-block-image size-large"><a href="https://ceronman.com/wp-content/uploads/2021/07/screenshot-from-2021-05-08-17-32-48-1.png"><img loading="lazy" width="937" height="1024" data-attachment-id="588" data-permalink="https://ceronman.com/screenshot-from-2021-05-08-17-32-48-1/" data-orig-file="https://ceronman.com/wp-content/uploads/2021/07/screenshot-from-2021-05-08-17-32-48-1.png" data-orig-size="2000,2186" data-comments-opened="0" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="screenshot-from-2021-05-08-17-32-48-1" data-image-description="" data-image-caption="" data-medium-file="https://ceronman.com/wp-content/uploads/2021/07/screenshot-from-2021-05-08-17-32-48-1.png?w=274" data-large-file="https://ceronman.com/wp-content/uploads/2021/07/screenshot-from-2021-05-08-17-32-48-1.png?w=937" src="https://ceronman.com/wp-content/uploads/2021/07/screenshot-from-2021-05-08-17-32-48-1.png?w=937" alt="" class="wp-image-588" srcset="https://ceronman.com/wp-content/uploads/2021/07/screenshot-from-2021-05-08-17-32-48-1.png?w=937 937w, https://ceronman.com/wp-content/uploads/2021/07/screenshot-from-2021-05-08-17-32-48-1.png?w=1874 1874w, https://ceronman.com/wp-content/uploads/2021/07/screenshot-from-2021-05-08-17-32-48-1.png?w=137 137w, https://ceronman.com/wp-content/uploads/2021/07/screenshot-from-2021-05-08-17-32-48-1.png?w=274 274w, https://ceronman.com/wp-content/uploads/2021/07/screenshot-from-2021-05-08-17-32-48-1.png?w=768 768w" sizes="(max-width: 937px) 100vw, 937px" /></a></figure>



<p>One of the problems was related to my GC implementation and the way I was dereferencing my index-based pointers. Using vector indices is slower than a regular pointer dereference. An arithmetic operation is needed to get the address of the element, but more importantly, Rust will always check if the index is out of bounds. For the vast majority of use cases, these extra steps are completely negligible, however when you have a VM that processes ~350 million instructions per second, and then you have to do three or four dereferences per instruction, then it shows. But even then, this was not the main problem. The big problem was with some of the workarounds that I had to add to please the borrow checker. I’ll try to explain this:</p>



<p>The core of a VM is basically a huge loop that increments the <em>program counter</em> (PC), grabs the next instruction and runs a big <code>match</code> expression. The PC is part of the current frame. The current frame has a reference to a closure object, which has a reference to a function object, which then has a reference to the chunk of bytecode that contains the instructions. In code it roughly looks like this:</p>



<!-- HTML generated using hilite.me --><div style="background:#ffffff;overflow:auto;width:auto;background:#ffffff;width:auto;border:solid gray;border-width:0.1em 0.1em 0.1em 0.8em;padding:0.1em;"><pre style="margin:0;line-height:125%;"><span style="color:#0000ff;">loop</span> {
    <span style="color:#0000ff;">let</span> <span style="color:#0000ff;">mut</span> frame = self.frames.last_mut().unwrap();
    <span style="color:#0000ff;">let</span> closure = self.gc.deref(frame.closure);
    <span style="color:#0000ff;">let</span> function = self.gc.deref(closure.function);
    <span style="color:#0000ff;">let</span> chunk = &amp;function.chunk;
    <span style="color:#0000ff;">let</span> instruction = chunk.code[frame.ip];
    frame.ip += 1;
    <span style="color:#0000ff;">match</span> instruction {
        ...
    }
}
</pre></div>



<p>The first part of the loop is what was causing the problem. However, I don’t really need to do this on every single iteration. For most instructions, the active frame and chunk of bytecode remains the same. The current frame only changes when a function is invoked or when the current function returns. I could store this in a local variable as a reference and change it only on those instructions, for example:</p>



<!-- HTML generated using hilite.me --><div style="background:#ffffff;overflow:auto;width:auto;background:#ffffff;width:auto;border:solid gray;border-width:0.1em 0.1em 0.1em 0.8em;padding:0.1em;"><pre style="margin:0;line-height:125%;"><span style="color:#0000ff;">let</span> <span style="color:#0000ff;">mut</span> frame = self.frames.last_mut().unwrap();
<span style="color:#0000ff;">let</span> closure = self.gc.deref(frame.closure);
<span style="color:#0000ff;">let</span> function = self.gc.deref(closure.function);
<span style="color:#0000ff;">let</span> <span style="color:#0000ff;">mut</span> chunk = &amp;function.chunk;
<span style="color:#0000ff;">loop</span> {
    <span style="color:#0000ff;">let</span> instruction = chunk.code[frame.ip];
    frame.ip += 1;
    <span style="color:#0000ff;">match</span> instruction {
        Instruction::Call =&gt; {
            <span style="color:#008000;">// update frame and chunk</span>
        }
    }
}
</pre></div>



<p>This would increase the speed considerably. But there is a problem: Rust is not very happy about it. The way my implementation works is that the GC owns every object created. If I need an object, I could borrow it, and while I borrow it I’m also borrowing the whole GC. Because of Rust’s aliasing rules, if I decide to have a long-lived reference to the current chunk of byte code, I won’t be able to ever borrow mutably from the GC. So this causes a ton of borrow checker complaints. That’s why I ended up returning every borrow immediately. But this implies a ton of unnecessary dereferences.</p>



<p><em>Side note: A similar issue with the borrow checker that I often encountered is the one of interprocedural conflicts. There is a nice </em><a href="http://smallcultfollowing.com/babysteps/blog/2018/11/01/after-nll-interprocedural-conflicts/"><em>blog post by Niko Matsakis</em></a><em> explaining this problem. I would love to see Rust improving in this area, as I see it as a major headache for beginners.</em></p>



<p>I tried quite some different approaches to work around this with safe Rust, but I failed on every single one of them. This was often frustrating because it required long refactorings and it was only until the end that I realized that it doesn’t work.&nbsp;</p>



<p>A simpler solution was to use raw pointers instead of references. This is easy to implement but requires unsafe blocks to dereference those two pointers. I ended up doing that and improvement was massive, with some benchmarks taking up to 74% less time.</p>



<p>After doing this I also decided to rewrite the GC and make the references wrap raw pointers instead of vector indices. This also required some unsafe code, but it also came with some nice speed improvements. And even better, it allowed me to get rid of a lot of boilerplate code because I could finally use <a href="https://doc.rust-lang.org/std/ops/trait.Deref.html">Deref</a>. So instead of doing things like</p>



<!-- HTML generated using hilite.me --><div style="background:#ffffff;overflow:auto;width:auto;background:#ffffff;width:auto;border:solid gray;border-width:0.1em 0.1em 0.1em 0.8em;padding:0.1em;"><pre style="padding:0.5em;margin:0;line-height:125%;"><span style="color:#0000ff;">let</span> closure = self.gc.deref(frame.closure);
<span style="color:#0000ff;">let</span> function = self.gc.deref(closure.function);
<span style="color:#0000ff;">let</span> chunk = &amp;function.chunk;
</pre></div>



<p>I could simply:</p>



<!-- HTML generated using hilite.me --><div style="background:#ffffff;overflow:auto;width:auto;background:#ffffff;width:auto;border:solid gray;border-width:0.1em 0.1em 0.1em 0.8em;padding:0.1em;"><pre style="margin:0;line-height:125%;"><span style="color:#0000ff;">let</span> chunk = frame.closure.function.chunk;
</pre></div>



<p>This simplified a lot of code, and after these changes, my benchmarks improved considerably:</p>



<figure class="wp-block-image size-large"><a href="https://ceronman.com/wp-content/uploads/2021/07/image-3.png"><img loading="lazy" width="884" height="1024" data-attachment-id="596" data-permalink="https://ceronman.com/image-3/" data-orig-file="https://ceronman.com/wp-content/uploads/2021/07/image-3.png" data-orig-size="1742,2018" data-comments-opened="0" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="image-3" data-image-description="" data-image-caption="" data-medium-file="https://ceronman.com/wp-content/uploads/2021/07/image-3.png?w=259" data-large-file="https://ceronman.com/wp-content/uploads/2021/07/image-3.png?w=884" src="https://ceronman.com/wp-content/uploads/2021/07/image-3.png?w=884" alt="" class="wp-image-596" srcset="https://ceronman.com/wp-content/uploads/2021/07/image-3.png?w=884 884w, https://ceronman.com/wp-content/uploads/2021/07/image-3.png?w=129 129w, https://ceronman.com/wp-content/uploads/2021/07/image-3.png?w=259 259w, https://ceronman.com/wp-content/uploads/2021/07/image-3.png?w=768 768w, https://ceronman.com/wp-content/uploads/2021/07/image-3.png 1742w" sizes="(max-width: 884px) 100vw, 884px" /></a></figure>



<p>I was still far from the speed of <em>clox</em>, but at least I was already better than <em>jlox</em> and very close to Python and Perl.</p>



<h2 class="wp-block-heading">Improving HashMap performance</h2>



<p>The next thing that showed up in the profiler was <code>HashMap</code> operations. This was kind of expected. Like most dynamic languages, Lox uses hash tables heavily. They’re used to store global variables, interning strings, fields and methods. Any improvement in this area will definitely have a huge impact on the overall performance of the interpreter. In fact, the last chapter of the book, which is dedicated to optimizations, shows how a tiny change in the hash table code allows to shave up to 42% of the running time of a benchmark. That was impressive.</p>



<p>The easiest thing to try was to change the hashing algorithm. The <code>HashMap</code> implementation in Rust’s standard library uses <a href="https://en.wikipedia.org/wiki/SipHash">SipHash</a> by default, while <em>clox</em> uses <a href="https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function">FNV</a>. I knew that <em>SipHash</em> is not that fast, so I thought I could get some easy wins replacing it. In Rust it’s very easy to switch hash function implementations. Just use a different constructor and the rest of the code remains intact.</p>



<p>I found a Rust <a href="https://crates.io/crates/fnv">crate</a> that implements the FNV algorithm, but I also found one called <a href="https://crates.io/crates/ahash">aHash</a> which claims to be “the fastest, DOS resistant hash currently available in Rust”. I tried both and indeed <em>aHash</em> gave better results.</p>



<p>With this tiny change I was able to shave up to 45% of the running time of some of the benchmarks. That’s super amazing for such a small change.</p>



<p>Later I found out that the Rust compiler uses another hashing algorithm called <a href="https://crates.io/crates/fxhash">fxhash</a>. Even though <em>aHash</em> claims to be faster than <em>fxhash</em>, given how easy it is to switch algorithms, I decided to try it. I was surprised to find improvements on all of the benchmarks. In some cases shaving up to 25% of time from the <em>aHash</em> results!</p>



<p><em>Side note: Don’t get super excited about these results. There is a very good reason why Rust uses SipHash by default. Algorithms such as FNV and fxhash are prone to </em><a href="https://en.wikipedia.org/wiki/Algorithmic_complexity_attack"><em>algorithmic complexity DOS attacks</em></a><em>. It’s probably not a good idea to use them for an interpreter. But given that this is not a real-world language, and I’m trying to match clox speed using FNV, I decided to ignore this fact for the moment. aHash, however, claims to be DOS resistant, which might be a very interesting option for a real language.</em></p>



<p>The improvements of switching hash function were quite significant. However, the profiler kept showing some performance bottlenecks caused by hash table operations. I also profiled <em>clox</em> and I found out that hash operations were not taking that much time there. I had to investigate more.</p>



<p>Rust’s standard library is using a very sophisticated hash map implementation called <a href="https://github.com/rust-lang/hashbrown">HashBrown</a>. This is a port of <a href="https://abseil.io/about/design/swisstables">Google’s SwissTables</a>, a high-performance hash map implementation in C++. It even uses SIMD instructions to scan multiple hash entries in parallel. How could I ever improve on that? This seemed completely impossible.</p>



<p>So I decided to re-read the chapter of Crafting Interpreters dedicated to hash tables to see if I was missing any tricks. And this was the case indeed!</p>



<p>Unlike <em>HashBrown</em>, which is a general-purpose hash table implementation, the hash table in <em>clox</em> is tailored for a very specific use case. While <em>HashBrown</em> is generic, <em>clox</em>&#8216;s <code>Table</code> only uses Lox strings as keys and Lox values as values. Lox strings are immutable, interned, and they can cache their own hashes. This means that hashing only occurs once ever for each string and comparison is as fast as comparing two pointers. Additionally, not dealing with generic types has the advantage of ignoring type system edge cases such as <a href="https://doc.rust-lang.org/nomicon/exotic-sizes.html#zero-sized-types-zsts">Zero Sized Data Types</a>.</p>



<p>So I decided to bite the bullet and write my own hash map implementation in Rust closely following the code from <em>clox</em>. The results were very positive, I was able to shave time on most of the benchmarks, with a cut of 44% for the best case compared to <em>HashBrown</em> with <em>fxhash</em>. In the end, it was not a lot of code either. My hash map implementation is roughly 200 lines of mostly unsafe Rust.</p>



<p><em>Side note: Before writing my own hash table, I tried to mimic the same special conditions of clox tables using HashBrown. For example, I implemented PartialEq on GcRef&lt;String&gt; to ensure that the comparison of interned strings were done by comparing pointers. And I also implemented my own caching hash function based on fxhash. But these efforts didn’t show any significant results. The simplicity of the clox hashmap implementation is just fast!</em></p>



<h2 class="wp-block-heading">The price of dynamic dispatch</h2>



<p>I was getting closer to the speed of <em>clox</em>, but there was a long way to go. One thing I noticed is that the time difference was much bigger in the benchmarks that ended up stressing the GC. The profiler showed that the tracing part of the garbage collection process was taking quite a lot of time.</p>



<p>As I mentioned before, I used trait objects to keep track of anything that should be garbage collected. I copied this idea from crates such as <a href="https://crates.io/crates/gc">gc</a> and <a href="https://crates.io/crates/gc-arena">gc_arena</a>. Using a trait object allowed me to keep a list of all the objects, which is necessary for the sweeping process. The trait also would contain methods for tracing an object. Each object type had different ways of tracing. For example, a string should only mark itself, but an object instance should mark itself and its fields. Each garbage collected type should implement the <code>GcTrace</code> trait with the specific logic to trace it. Then, thanks to polymorphism, the tracing part of the garbage collector was as simple as this:</p>



<!-- HTML generated using hilite.me --><div style="background:#ffffff;overflow:auto;width:auto;background:#ffffff;width:auto;border:solid gray;border-width:0.1em 0.1em 0.1em 0.8em;padding:0.1em;"><pre style="font-size:0.7em;padding:0.5em;margin:0;line-height:125%;"><span style="color:#0000ff;">fn</span> trace_references(&amp;<span style="color:#0000ff;">mut</span> self) {
    <span style="color:#0000ff;">while</span> <span style="color:#0000ff;">let</span> Some(object) = self.grey_stack.pop() {
        object.trace(self);
    }
}
</pre></div>



<p>As usual with polymorphism, this was short and elegant. I liked it a lot. However, there was a problem: This kind of polymorphism uses <a href="https://en.wikipedia.org/wiki/Dynamic_dispatch">dynamic dispatch</a>, which has a cost. In this particular case, the compiler is unable to inline the tracing functions, so every single trace of an object is a function call. Again, this is usually not a big problem, but when you have millions of traces per second, it shows. In comparison, <em>clox</em> was simply using a <code>switch</code> statement. This is less flexible but the compiler inlines it tightly which makes it really fast.</p>



<p>So instead of using a trait object, I rewrote the GC to use an <code>enum</code> instead. Then I wrote a <code>match</code> expression that would do the right tracing logic for each type. This is a bit less flexible, and it also wastes memory because the <code>enum</code> effectively makes all objects use the same space. But it also improved tracing speed considerably with up to 28% less time for the most problematic benchmark.</p>



<p><em>Side note: clox uses a different approach called </em><a href="https://craftinginterpreters.com/strings.html#struct-inheritance"><em>Struct Inheritance</em></a><em>. There is a struct that acts as a header and contains meta-information about each object. Then each struct that represents an object managed by the GC has this header as its first field. Using </em><a href="https://en.wikipedia.org/wiki/Type_punning"><em>type punning</em></a><em>, it’s possible to cast a pointer to the header to a specific object and vice versa. This is possible because in C structs are laid out in the same order as defined in the source. Rust by default doesn’t guarantee the order of the data layout, so this technique is not possible. There are ways to tell the Rust compiler to use the same data layout as C, which is used for compatibility, but I wanted to stay with Rust as intended.</em></p>



<h2 class="wp-block-heading">Small unsafety speedups</h2>



<p>There were other small details that made <em>clox</em> faster and were related to avoiding safety checks. For example, the stack in <em>clox</em> is represented by a fixed-size array and a pointer that indicates the top of the stack. No underflow or overflow checks are done at all. In contrast, in my Rust implementation, I was using a <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html">Vec</a> and the standard <code>push()</code> and <code>pop()</code> operations which are, of course, checked. I rewrote the stack code to use a similar approach as <em>clox</em> and I was able to shave up to 25% of the running time.</p>



<p>Similarly, the program counter in <em>clox</em> is represented as a C pointer to the next instruction in the bytecode array. Increasing the PC is done with pointer arithmetic and no checks. In my Rust implementation, the PC was an integer with the index in the position in the bytecode chunk vector. Changing this to work as <em>clox</em> allowed me to shave up to 11% from the running time.</p>



<p>Getting speed-up improvements is nice, but the downside is that the code becomes unsafe. One of the best parts of Rust is its safety, and if you abandon it, it feels as dangerous like C but a bit uglier. But at least it’s nice that you can be very specific about what parts of your code are unsafe, this makes it much easier to debug when things go wrong.</p>



<p><em>Side note: How can clox live with all these unchecked pointer arithmetic? Well, the VM assumes that the bytecode will always be correct. The VM is not supposed to take any arbitrary bytecode, but only bytecode generated by the compiler. It’s the compiler&#8217;s responsibility to produce correct bytecode that would not cause underflows or overflows of the stack or frames. While the clox compiler does prevent a lot of these cases, it does not prevent stack overflows. The author intentionally decided to skip this check because it would require a lot of boilerplate code. Real-world interpreters using unsafe structures like these must absolutely do it though.</em></p>



<p>After the tweaks, my Rust implementation finally started to get really close to <em>clox</em>:</p>



<figure class="wp-block-image size-large"><a href="https://ceronman.com/wp-content/uploads/2021/07/image-5.png"><img loading="lazy" width="884" height="1024" data-attachment-id="602" data-permalink="https://ceronman.com/image-5/" data-orig-file="https://ceronman.com/wp-content/uploads/2021/07/image-5.png" data-orig-size="1742,2018" data-comments-opened="0" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="image-5" data-image-description="" data-image-caption="" data-medium-file="https://ceronman.com/wp-content/uploads/2021/07/image-5.png?w=259" data-large-file="https://ceronman.com/wp-content/uploads/2021/07/image-5.png?w=884" src="https://ceronman.com/wp-content/uploads/2021/07/image-5.png?w=884" alt="" class="wp-image-602" srcset="https://ceronman.com/wp-content/uploads/2021/07/image-5.png?w=884 884w, https://ceronman.com/wp-content/uploads/2021/07/image-5.png?w=129 129w, https://ceronman.com/wp-content/uploads/2021/07/image-5.png?w=259 259w, https://ceronman.com/wp-content/uploads/2021/07/image-5.png?w=768 768w, https://ceronman.com/wp-content/uploads/2021/07/image-5.png 1742w" sizes="(max-width: 884px) 100vw, 884px" /></a></figure>



<p>For most benchmarks, the running time of <em>loxido</em> is between 20% and 50% more than <em>clox</em>. It’s close, but not entirely satisfactory. Unfortunately, I reached a point where profiling my existing benchmarks doesn’t give me clear information about what parts of the code are making <em>loxido</em> slower.</p>



<p>I probably need to write some more targeted benchmarks. And I should start looking for clues beyond the profiler data, such as checking for cache misses, branch mispredictions and taking a look at the generated machine code. But this goes beyond my available time and knowledge, so I decided to leave <em>loxido</em> as it is here.</p>



<p>I have a few hunches of things that could improve performance. One is using struct inheritance to represent GC objects instead of using an <code>enum</code>. This would require changing the data layout of the structs to match C. The problem with using an <code>enum</code> is that a <code>match</code> operation is required on every dereference. I believe this <code>match</code> should be optimized out by the compiler, but I haven’t properly checked. But even then, struct inheritance is simpler and it will require fewer instructions in many places.</p>



<p>The second hunch is that perhaps using variable-length instructions might end up in a tighter bytecode that produces better cache utilization. I feel this is unlikely as the byte code is usually so small that I find it hard that this makes any difference. But I would like to have the time to test it anyway.</p>



<p>I also considered the fact that I compiled <em>clox</em> using GCC 10.3.1, while Rust 1.51.0 uses LLVM. I tried compiling <em>clox</em> using <a href="https://clang.llvm.org/">clang</a> instead and indeed some benchmarks took up to 15% more time. But a few others were faster than the GCC version. So I discarded this as a big factor. My Rust implementation is consistently slower on all the benchmarks.</p>



<p>One more thing to consider was the impact of the <a href="https://brionv.com/log/2018/05/17/javascript-engine-internals-nan-boxing/">NaN boxing optimization</a>. Which I had zero plans to implement in Rust. I compiled <em>clox</em> without NaN boxing and compared the results. It almost made no difference. There were time variations of +- 5% across the benchmarks. So I don’t think this is a factor at all.</p>



<h2 class="wp-block-heading">Final Thoughts</h2>



<p>I enjoyed writing Rust very much and learning how to write a language VM with it. <a href="https://craftinginterpreters.com/">Crafting Interpreters</a> is one of the most amazing technical books that I have ever read, I totally recommend it.</p>



<p>Rust can be frustrating sometimes, that’s undeniable. But Rust is also very rewarding. Besides the modern features in the language and its great tooling, I find the Rust community to be awesome. I know the hype can be annoying sometimes, especially when fans feel the need to jump into every single discussion to evangelize about the language, but, for the most part, the hype has a lot of positive things. The Rust community is vibrant, people are sharing knowledge all the time in the form of blog posts, discussions, tools, and libraries. The community is also very beginner-friendly, with tons of people willing to help even when the question has been repeated a thousand times in multiple places.</p>



<p>In some areas, Rust feels a bit half-baked. For example, dealing with variance in the type system is confusing and feels very hacky. The new allocator API is not there yet, which would have been very useful when writing my GC. And I think the borrow checker could be smarter in many cases. I would like to write in more detail about these things, but this post is already too long. Nevertheless, I think the language has very good prospects of improving and I’m glad the creators are not afraid of the language not being perfect. I look forward to keeping writing Rust and learning about it.</p>



<p>This is it! Thanks for reading!</p>
]]></content:encoded>
					
					<wfw:commentRss>https://ceronman.com/2021/07/22/my-experience-crafting-an-interpreter-with-rust/feed/</wfw:commentRss>
			<slash:comments>2</slash:comments>
		
		
		
		<media:content url="https://2.gravatar.com/avatar/8446d2ad9b9d7eb75d269da1966fd480dda55da09158a64d1779445af3a58b5b?s=96&#38;d=https%3A%2F%2Fs0.wp.com%2Fi%2Fmu.gif&#38;r=G" medium="image">
			<media:title type="html">ceronman</media:title>
		</media:content>

		<media:content url="https://ceronman.com/wp-content/uploads/2021/07/image-2.png?w=884" medium="image" />

		<media:content url="https://ceronman.com/wp-content/uploads/2021/07/screenshot-from-2021-05-08-17-32-48-1.png?w=937" medium="image" />

		<media:content url="https://ceronman.com/wp-content/uploads/2021/07/image-3.png?w=884" medium="image" />

		<media:content url="https://ceronman.com/wp-content/uploads/2021/07/image-5.png?w=884" medium="image" />
	</item>
		<item>
		<title>Is Rust a Functional Language in Disguise?</title>
		<link>https://ceronman.com/2020/09/17/is-rust-a-functional-language-in-disguise/</link>
					<comments>https://ceronman.com/2020/09/17/is-rust-a-functional-language-in-disguise/#comments</comments>
		
		<dc:creator><![CDATA[ceronman]]></dc:creator>
		<pubDate>Thu, 17 Sep 2020 19:57:38 +0000</pubDate>
				<category><![CDATA[Functional Programming]]></category>
		<category><![CDATA[Rust]]></category>
		<guid isPermaLink="false">http://ceronman.com/?p=501</guid>

					<description><![CDATA[This is something I’ve been asking myself while learning Rust. Yes, I know that this sounds like a weird question to ask as it’s no secret that Rust has huge influence from the functional programming world. Closures, iterators, pattern matching, algebraic data types; these are features inspired by FP languages, so obviously you can do &#8230; <a href="https://ceronman.com/2020/09/17/is-rust-a-functional-language-in-disguise/" class="more-link">Continue reading <span class="screen-reader-text">Is Rust a Functional Language in&#160;Disguise?</span> <span class="meta-nav">&#8594;</span></a>]]></description>
										<content:encoded><![CDATA[
<p>This is something I’ve been asking myself while learning Rust. Yes, I know that this sounds like a weird question to ask as it’s no secret that Rust has huge influence from the functional programming world. Closures, iterators, pattern matching, algebraic data types; these are features inspired by FP languages, so obviously you can do functional programming with Rust. But that’s not really my question. What I’m asking is if Rust is a <strong>mainly</strong> functional language.</p>



<p>These days most mainstream imperative languages have functional features, you can do FP in any of them, but that doesn’t mean that those languages are considered functional. On the other hand, some languages are designed mainly to be functional, I’m talking about Haskell, Clojure, OCaml or Erlang. So, to be more clear, I can rephrase my question as: Is Rust a language designed to be used mainly for functional programming? Or is it another imperative language where you can optionally use FP?</p>



<p>At first glance, it looks like the answer is simple. Rust very much looks like an imperative language with support for some popular features from functional languages. But after a closer look at the language, I’ve come to realize that it is closer to a purely functional language than I thought. It is <strong>a functional language disguised as imperative</strong>. I will try to explain what I mean in this post.</p>



<h2 class="wp-block-heading">What is functional programming?</h2>



<p>Before explaining why I think that Rust is mainly a functional language, it is a good idea to first explain what functional programming is. This is not as easy as it sounds, so first a disclaimer: This is far from a formal definition, but rather a hand-wavy explanation of what I understand as FP.</p>



<p class="has-text-align-left"><em>Side note: I am making this disclaimer because in the past I’ve experienced some quite angry responses from FP enthusiasts about this point of view. That made me quit FP for a while until I found the very friendly Clojure community. And I’m happy to report that in my first steps with Rust so far I have met an equally friendly community.</em></p>



<p>The core ideas behind Functional Programming are immutability and lack of side effects. That’s it. If you mostly use pure functions that receive data and return data without mutating any sort of external state, then you’re doing FP. On the other hand, if you mostly call functions or methods that alter or mutate some external state, then you are doing imperative programming.</p>



<p>To avoid side effects, functional languages use immutable data structures. Let’s jump to some small code examples to illustrate this difference. I know these examples are a bit silly and there are other ways to write them, but I just want a simple code example to illustrate my point. Here is how you use a hash map (dictionary) in Python, which is a mainly imperative language:</p>


<div style="background:#ffffff;overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.1em;">
<pre style="font-size:.7em;padding:.5em;margin:0;line-height:125%;">film = {}
film[<span style="color:#a31515;">"title"</span>] = <span style="color:#a31515;">"Fargo"</span>
film[<span style="color:#a31515;">"director"</span>] = <span style="color:#a31515;">"Joel Coen"</span>
</pre>
</div>


<p>And here is how you use a hash map in Clojure, a mainly functional language:</p>


<div style="background:#ffffff;overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.1em;">
<pre style="font-size:.7em;padding:.5em;margin:0;line-height:125%;">(<span style="color:#0000ff;">let </span>[film1 {}
      film2 (assoc film1 <span style="color:#a31515;">"title"</span> <span style="color:#a31515;">"Fargo"</span>)
      film3 (assoc film2 <span style="color:#a31515;">"director"</span> <span style="color:#a31515;">"Joel Coen"</span>)])
</pre>
</div>


<p>The main difference between these two approaches is that in Python you create one map, then you mutate it to add some entries to it. In Clojure you can’t mutate the map, instead, what you can do is to create a new map based on the previous one.</p>



<p>Now, let’s check how the same thing looks in Rust:</p>


<div style="background:#ffffff;overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.1em;">
<pre style="font-size:.7em;padding:.5em;margin:0;line-height:125%;"><span style="color:#0000ff;">let</span> <span style="color:#0000ff;">mut</span> film = HashMap::new();
film.insert(<span style="color:#a31515;">"title"</span>, <span style="color:#a31515;">"fargo"</span>);
film.insert(<span style="color:#a31515;">"director"</span>, <span style="color:#a31515;">"Joel Coen"</span>);
</pre>
</div>


<p>The Rust example is much closer to the imperative Python than the functional Clojure. And just in case there is any doubt, we have the <strong>mut</strong> keyword right there, which means <strong>mutable</strong>.</p>



<p><em>Side note: Unlike some other languages that also have keywords to distinguish mutable and immutable values (<strong>final</strong> in java, <strong>const</strong> in JavaScript, <strong>readonly</strong> in C#, <strong>val</strong> in Kotlin), one interesting thing about Rust is that this applies to the whole value, not just the superficial reference. In Java, nothing prevents you from mutating a HashMap in a final reference. Rust won’t allow any sort of mutation unless you use <strong>mut</strong> (I’m going to conveniently ignore Interior Mutability for now, mostly because I think I don’t fully understand it yet).</em></p>



<p>So after looking at the code examples, we can conclude that Rust is mainly an imperative language. Or is it? I know that this sounds very counter intuitive, but I think that the Rust example is actually closer to the functional style than the imperative one. Yes, I’ll explain why at some point, please be patient.</p>



<h2 class="wp-block-heading">If a tree falls in the woods, does it make a sound?</h2>



<p>Here is the thing, pure Functional Programming is an illusion, it’s not real. Even the purest of the FP languages are mutating things and producing some side effects behind the scenes. Real computers are imperative machines. Your pure functions have to change registries, push stack frames, etc. So we can say that FP languages are merely an emulation, they are not&nbsp; the real thing. This doesn’t mean that FP doesn’t have any value, I actually think there is a lot of value in it. Especially in the fact that FP produces programs that are easier to understand and to maintain. But it’s important to understand that purity is unachievable.</p>



<p>Let’s take another look at my previous Clojure code example:</p>


<div style="background:#ffffff;overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.1em;">
<pre style="font-size:.7em;padding:.5em;margin:0;line-height:125%;">(<span style="color:#0000ff;">let </span>[film1 {}
      film2 (assoc film1 <span style="color:#a31515;">"title"</span> <span style="color:#a31515;">"Fargo"</span>)
      film3 (assoc film2 <span style="color:#a31515;">"director"</span> <span style="color:#a31515;">"Joel Coen"</span>)])
</pre>
</div>


<p>Here Clojure doesn’t really create entirely new data structures on every operation. That would be very inefficient. Instead, Clojure internally uses something called <a href="http://lampwww.epfl.ch/papers/idealhashtrees.pdf">Hash Array Mapped Tries (HAMT)</a>. When you use <strong>assoc</strong> in Clojure to add an entry to a map, it looks like it’s generating a completely new map, but in reality, both maps share most of the same internal structure, they are really one single HAMT, and <strong>assoc</strong> is actually mutating that HAMT.</p>



<p>So data structures in Clojure are actually mutable, but that doesn’t really matter because their interface is side effect free for the external world. Clojure is still a mainly functional language. And that’s a key aspect of FP; it’s not about completely avoiding mutation, that is impossible in real computers, it’s about hiding those mutations in a way that they don’t create side effects for the rest of the code. In FP we want our units of computation (functions) to depend only on their inputs and not on some external state. That’s what makes them easier to reason about.</p>



<p>Now back to our small Python example:</p>


<div style="background:#ffffff;overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.1em;">
<pre style="font-size:.7em;padding:.5em;margin:0;line-height:125%;">film[<span style="color:#a31515;">"title"</span>] = <span style="color:#a31515;">"Fargo"</span>
film[<span style="color:#a31515;">"director"</span>] = <span style="color:#a31515;">"Joel Coen"</span>
</pre>
</div>


<p>The key difference here, compared to the Clojure example, is that the world is not shielded from this mutation. We could have some class or other part of the code holding a reference to this map, and as soon as we mutate this we are creating a side effect for those parts of the code. This makes code harder to reason about. It’s the same reason why global variables are considered a bad practice, and it’s also the reason why many programmers prefer to use FP.</p>



<p>Let’s go back to the Rust example. This time I added a reference to the map, which will be the observer of the mutation side effect:</p>


<div style="background:#ffffff;overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.1em;">
<pre style="font-size:.7em;padding:.5em;margin:0;line-height:125%;"><span style="color:#0000ff;">let</span> <span style="color:#0000ff;">mut</span> film = HashMap::new();
<span style="color:#0000ff;">let</span> observer = &amp;film;
film.insert(<span style="color:#a31515;">"title"</span>, <span style="color:#a31515;">"fargo"</span>);
film.insert(<span style="color:#a31515;">"director"</span>, <span style="color:#a31515;">"Joel Coen"</span>);
println!(<span style="color:#a31515;">"{}"</span>, observer.len());
</pre>
</div>


<p>If you are a Rust programmer you of course know that <strong>this code won’t compile</strong>. Here is what the awesome Rust compiler says about it:</p>


<div style="background:#ffffff;overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.1em;">
<pre style="font-size:.7em;padding:.5em;margin:0;line-height:125%;">error[E0502]: cannot borrow `film` as mutable because it is also borrowed as immutable
 --&gt; src/main.rs:6:5
  |
5 |     let observer = &amp;film;
  |                    ----- immutable borrow occurs here
6 |     film.insert("title", "fargo");
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ mutable borrow occurs here
7 |     film.insert("director", "Joel Coen");
8 |     println!("{}", observer.len());
  |                    -------- immutable borrow later used here
</pre>
</div>


<p>This error happens because Rust’s ownership and borrowing rules only allow either one single mutable reference or many immutable ones. In other words,<strong> if you are going to mutate an object in Rust, you can’t have any other part of the code holding a reference to that object</strong>. This is mostly checked statically by the compiler. So mutation in Rust is like a tree falling in the forest where there is no one to hear it. It’s a mutation that doesn’t produce side effects. And this is exactly what FP is about.</p>



<h2 class="wp-block-heading">The struggles of learning a language</h2>



<p>Rust has not been as easy to learn for me as other languages. The borrow checker, which is the part that verifies the mutability and lifetime of references, is famous among Rust beginners as the toughest part to get used to.</p>



<p>While struggling with the borrow checker I started to notice something: the kinds of patterns that caused me trouble with the borrow checker are very similar to the ones that caused me trouble when learning functional programming. For example, when I was learning Clojure by solving some <a href="https://adventofcode.com/">Advent of Code</a> problems, I got to a problem where the best solution was to use a circularly linked list. I was trying to solve the problems using pure FP and I quickly hit a wall. Later on, when I needed a similar data structure in Rust I also hit a wall. This kind of data structures are hard to implement both in pure FP and in Rust.</p>



<p><em>Side note: There is a fantastic tutorial called <a href="https://rust-unofficial.github.io/too-many-lists/">Learning Rust with Entirely Too Many Linked Lists</a>, by Alexis Beingessner. It&#8217;s a great resource for learning to deal with the borrow checker in a practical way. This has been a lifesaver!</em></p>



<p>The similarity in the struggles is what made me think that perhaps Rust is way more functional than it appears to be and that approaching Rust in an imperative way is only a sure path to borrow checker headaches. But this is hard to realize because Rust does look very imperative, so your intuition is to use it in that way.</p>



<p>There is one huge positive aspect of this imperative appearance though: It’s much easier to reason about performance. Once you pass the borrow checker, your code just looks very similar to some imperative C. This contrasts with the deep abstractions that you often find in functional languages (e.g. HAMTs, lazy sequences) where unless you are well versed in the internals, it’s hard to predict how a given piece of code will perform.</p>



<h2 class="wp-block-heading">Verdict</h2>



<p>Back to the beginning, is Rust a mainly functional language? Well, I don’t know. The borrow checker certainly makes it very different from traditional imperative languages. But there is more to FP than mutation side effects. <em>IO</em> is another common cause of side effects. Printing to the screen, writing a file, sending a network request. The more pure functional languages like Haskell take these into account, but others like Clojure ignore them, letting you create these side effects from any function without ceremony. And so does Rust, so I wouldn&#8217;t rule it out of the FP category.</p>



<p>Functional composition is another key aspect of FP. There is <strong>map</strong>, <strong>filter</strong> and <strong>fold</strong> in Rust, but functional composition doesn’t seem to be as idiomatic as in FP languages. Recursion is also not very idiomatic in Rust. This is mostly because you actually have <strong>mut</strong>, so you can have imperative loops, whereas in FP languages you can’t mutate local variables so recursion is your only choice. At the smaller scale, Rust is definitely imperative. But I personally think that FP doesn’t bring any advantage at the small scale. It’s at the big scale when avoiding side effects really pays off. That’s the big advantage that FP brings to the table, and that one is covered by Rust’s borrowing rules.</p>



<p>So the verdict is not definitive. I can’t fully say that Rust is a functional language. But one thing that I’m sure of is that Rust is one of the most interesting languages that I have learned so far. The ownership and borrowing system is an amazing innovation that goes way beyond allowing memory safety without garbage collection. This system is actually bringing the best of the functional and imperative worlds together. And I’m very much looking forward to using and learning more about Rust.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://ceronman.com/2020/09/17/is-rust-a-functional-language-in-disguise/feed/</wfw:commentRss>
			<slash:comments>1</slash:comments>
		
		
		
		<media:content url="https://2.gravatar.com/avatar/8446d2ad9b9d7eb75d269da1966fd480dda55da09158a64d1779445af3a58b5b?s=96&#38;d=https%3A%2F%2Fs0.wp.com%2Fi%2Fmu.gif&#38;r=G" medium="image">
			<media:title type="html">ceronman</media:title>
		</media:content>
	</item>
		<item>
		<title>Perl 6: Giving with One Hand and Taking with the Other</title>
		<link>https://ceronman.com/2015/02/23/perl-6-giving-with-one-hand-and-taking-with-the-other/</link>
		
		<dc:creator><![CDATA[ceronman]]></dc:creator>
		<pubDate>Mon, 23 Feb 2015 20:28:46 +0000</pubDate>
				<category><![CDATA[Uncategorized]]></category>
		<guid isPermaLink="false">http://ceronman.com/?p=427</guid>

					<description><![CDATA[I&#8217;ve been programming Perl full-time for almost two years now. The reason is my new job, where 99% of back-end our code base is Perl. Before that, I had not written a single line of Perl, so the language has been a new experience for me. I think Perl is actually better than its reputation. &#8230; <a href="https://ceronman.com/2015/02/23/perl-6-giving-with-one-hand-and-taking-with-the-other/" class="more-link">Continue reading <span class="screen-reader-text">Perl 6: Giving with One Hand and Taking with the&#160;Other</span> <span class="meta-nav">&#8594;</span></a>]]></description>
										<content:encoded><![CDATA[<p>I&#8217;ve been programming Perl full-time for almost two years now. The reason is my new job, where 99% of back-end our code base is Perl. Before that, I had not written a single line of Perl, so the language has been a new experience for me. I think Perl is actually better than its reputation. It is pleasant to write most of the time. I also love to see and understand how many cool features in other languages were inspired by Perl. Nevertheless, it&#8217;s undeniable that the language has pitfalls and design problems. This year, during FOSDEM, Larry Wall <a href="https://fosdem.org/2015/schedule/event/get_ready_to_party/">announced</a> that a first version of Perl 6 will be released before Christmas. For those not familiar with Perl, please notice that it&#8217;s not exactly the successor of Perl 5, but it&#8217;s rather a completely new and different language. Perl and Perl 6 are called sister languages. The idea of Perl 6 started fifteen years ago, when Larry Wall and others decided to design and implement a new language from scratch. The idea was to keep Perl&#8217;s essence, while fixing all of its design issues and quirks. I decided to give Perl 6 a try. Mostly because I was curious to see if it actually fixed the problems of Perl 5. I haven&#8217;t started a serious project or anything, I&#8217;ve been just playing with the language and solving some <a href="https://projecteuler.net/">Project Euler</a> problems. Also, I&#8217;ve started my tests with a pre-release version of Perl 6 (Rakudo Star with MoarVM version 2015.01), some things are not implemented and some others are not properly documented. If any Perl 6 dev ever reads this, please forgive me if something is wrong. I&#8217;ll be happy to be corrected. Both Perl 5 and Perl 6 languages are pretty big. The motto of these languages is &#8220;There is more than one way to do it&#8221; (<a href="http://en.wikipedia.org/wiki/There%27s_more_than_one_way_to_do_it">TIMTOWTDI</a>). So there are tons of features, many of them just to do the same things. I will only discuss a few of them. In particular, I will discuss how Perl 6 addresses those that I consider the biggest problems of Perl 5: context and references.</p>
<h2>First Big Problem: Context Variable Behavior</h2>
<p>Context is something very unique to Perl as far as I know. It&#8217;s a way to mimic spoken language where the meaning of some words depends on the context they&#8217;re used in. Perl 5 has 3 contexts: scalar, list and void. So for example, a function might do and return something completely different depending on the context of the call:</p>
<pre class="brush: perl; light: true; title: ; notranslate">
my $x = do_something(); # Scalar context: returns one thing.
print do_something();   # List context: might return other thing.
do_something();         # Void context: a third possibility.
</pre>
<p>When implementing a function, you can use the special <em>wantarray</em> construct to know in which context the function is being called. For example:</p>
<pre class="brush: perl; light: true; title: ; notranslate">
sub do_something {
if (wantarray) {
# this will run if called in List context
} elsif (defined wantarray) {
# this will run if called in Scalar context
} else {
# this will run if called in Void context
}
}
</pre>
<p>The reason I consider context one of the biggest problems of Perl 5 is because, unlike other bad &#8220;features&#8221;, it&#8217;s pretty much impossible to avoid. The concept is so fundamental to the language and its core libraries that you just have to learn to live with it. It&#8217;s important to be very careful of how you are calling your functions all the time, otherwise you might introduce bugs or even <a href="http://blog.gerv.net/2014/10/new-class-of-vulnerability-in-perl-web-applications/">security issues</a>. Unfortunatelly, there doesn&#8217;t seem to be a convention on what functions should return in each context. For example, the built-in function <em>keys</em> return the list keys of a hash table / dictionary when called in list context, but instead returns then number of keys if called in scalar context. However, the <em>splice</em> function removes elements from an array and returns them in list context but it only returns the last element in scalar context. Similarly, the regexp match operator returns a Boolean if the string matches in scalar context, but the matching groups in list context (only if groups were defined). And so on. All this makes Perl hard to learn because you have to read and memorize the documentation of all the functions, and their behaviors on different contexts. Things are rarely intuitive and I&#8217;ve seen developers with many years of Perl experience bitten by this from time to time.</p>
<h2>Second Big Problem: References</h2>
<p>The other big problem with Perl, in my opinion, are references. More specifically, array and hash references. To explain why these are a problem, first I have to describe Lists. Lists are a language construct in Perl that can be used to initialize data structures, passing arguments to functions or assigning variables. A list is basically a group of expressions separated by commas. For example:</p>
<pre class="brush: perl; light: true; title: ; notranslate">
my @array = (1, 2, 3);       # Initialize an array.
my ($one, $two) = (1, 2);    # Assign variables.
join('/', 'home', 'manuel'); # Arguments to a function.
</pre>
<p>One important thing about lists is that they flatten all the inner lists. For example, the following lines are equivalent:</p>
<pre class="brush: perl; light: true; title: ; notranslate">
my @array = (1, 2, 3, 4);
my @array = (1, (2, (3, 4)));
</pre>
<p>The flattening also happens if you use arrays as expressions, for example:</p>
<pre class="brush: perl; light: true; title: ; notranslate">
my @end = (3, 4);
my @array = (1, 2, @end); # same as (1, 2, 3, 4);
</pre>
<p>List flattening is actually a nice feature, it allows a lot of cool things such as destructuring of assignment and function arguments. However, it has a problem: it makes it difficult to create nested data structures such as arrays of arrays. To fix this, Perl introduced the concept of references. References are some sort of high level pointers. Instead of storing the actual data, references store a pseudo address which points to the data. The important aspect of references, in relation to the problem described above, is that they&#8217;re scalars, and as such they can be taken as a single element of an array. So you can&#8217;t have arrays of arrays in Perl because of the flattening feature, but you can have arrays of array references, which are a good substitute. For example:</p>
<pre class="brush: perl; light: true; title: ; notranslate">
my @a = (1, 2);
my @b = (3, 4);
my @parts = (\@a, \@b); # Two elements. Doesn't flatten.
</pre>
<p>Perl also provides a nice syntax for defining array references, so the code above could be better written as:</p>
<pre class="brush: perl; light: true; title: ; notranslate">
my @parts = ([1, 2], [3, 4]); # an array of two arrayrefs.
</pre>
<p>Or you can write it as a single array reference and the syntax is very similar to other programming languages:</p>
<pre class="brush: perl; light: true; title: ; notranslate">
my $arrayref = [ [1, 2], [3, 4] ];
</pre>
<p>A similar thing happens with hashes/dictionaries, which are constructed also with lists. To have nested hashes you have to use hash references. The problem with array references is that they behave completely differently in both list and scalar contexts. So every time you want to do something with them you have to know if you&#8217;re dealing with a real array or a reference. Just like context, this problem is unavoidable in Perl because you need references every time you need nested arrays, but you can&#8217;t use only references because most built-in functions to operate with collections accept real arrays instead. To illustrate this problem, let&#8217;s assume that you&#8217;re using an API with a get_employees() function, and you want to print the name of each one. Your code is different depending on whether the function returns an array or an arrayref:</p>
<pre class="brush: perl; light: true; title: ; notranslate">
# Array version:
my @employees = get_employes();
for my $employee (@employees) {
print $employee-&gt;name;
}

# Arrayref version:
my $employees = get_employes();
for my $employee (@{$employees}) {
print $employee-&gt;name;
}
</pre>
<p>So for every function returning a collection, you have to read the documentation and memorize if they return a reference or an array. Some libraries help you with this, for example, DBI (the database interface for Perl) adds a suffix to some functions indicating which kind of value they return:</p>
<pre class="brush: perl; light: true; title: ; notranslate">
@row = $sth-&gt;fetchrow_array();
$row = $sth-&gt;fetchrow_arrayref();
</pre>
<p>Other libraries make use of the <em>wantarray</em> special function to return an array when in list context or a reference when in scalar context. This sometimes helps, but it also creates even more confusion because it&#8217;s not a widespread idiom, so you have to check the documentation carefully anyway. To make things worse, Perl built-in functions usually work in a way that&#8217;s completely counterintuitive for people used to all this lists/array logic. For example, the <em>push</em> function can be used to add one or more elements to an array:</p>
<pre class="brush: perl; light: true; title: ; notranslate">
my @array = (1, 2, 3);
push(@array, 4, 5, 6); # will be (1, 2, 3, 4, 5, 6)
</pre>
<p>This looks perfectly fine, however, if you were paying attention at how lists work in Perl, you know that arguments passed to a function are lists, and lists flatten. So applying the flattening logic to the <em>push</em> function, these two lines should be equivalent:</p>
<pre class="brush: perl; light: true; title: ; notranslate">
push(@array, 4, 5, 6);
push(1, 2, 3, 4, 5, 6);
</pre>
<p>So how does Perl know when the array part of the arguments ends and the elements part starts? If you use the list/array logic, to make this work, the first element should be a reference. That way, you will know that the array to push into is the first element of the list. You&#8217;d use it like this:</p>
<pre class="brush: perl; light: true; title: ; notranslate">
push(\@array, 4, 5, 6);
</pre>
<p>But that&#8217;s not how the built-in <em>push</em> function works in Perl. So, how does it work? A very experienced Perl developer once told me that in general, I should not assume that built-in functions behave as regular functions, some times they use some magic. However, there is a feature that explains this: function prototypes. These are small specs added to each function specifying what each argument is. It allows you to override the flattening logic. For example, if you want to have a function that behaves like push, you have to use:</p>
<pre class="brush: perl; light: true; title: ; notranslate">
sub my_push(\@@) {
my ($array, @elements) = @_;
push @$array, @elements;
}
</pre>
<p>One more thing to look for when reading API documentation. Fortunately, it&#8217;s not common that libraries abuse this feature.</p>
<h2>Perl 6 to the Rescue?</h2>
<p>Let&#8217;s finally talk about Perl 6. Good news is that it addresses these issues. Although Perl 6 still has a concept of context, it&#8217;s completely different from what Perl 5 uses. In practical terms this means that there is no <em>wantarray</em> function (yay!). Instead context flows outwards. That means that functions just return objects that know how to behave in different scenarios using methods for it. For example, if you want to represent an object as a string, you implement an <em>Str</em> method. If you want it as a number, you implement a <em>Numeric</em> method and so on. That&#8217;s not much different from what other languages do, it&#8217;s a well known pattern. Perl 6 also drops references. Everything is an object now. In fact you can assign arrays to scalar variables and use them almost in the same way as regular arrays:</p>
<pre class="brush: perl; light: true; title: ; notranslate">
$./perl6
&gt; my @array = 1, 2, 3, 4;
1 2 3 4
&gt; @array.elems # returns the number of elements in the array.
4
&gt; @array[0] # element access
1
&gt; @array[0] = 10 # assigning an element
10
&gt; say @array;
10 2 3 4
&gt;
&gt; # scalars work in the same way:
&gt; my $scalar = @array;
10 2 3 4
&gt; $scalar.elems
4
&gt; $scalar[0]
10
&gt; $scalar[0] = 1
1
&gt; say $scalar
1 2 3 4
</pre>
<p>So, if arrays behave like objects, and you can assign them to scalar variables and use them in the same way, why does Perl 6 still use sigils (the symbol before the variable name) to differentiate arrays from scalars? The answer is that, unfortunately, we still have context in Perl 6. And we still have flattening lists, and everything is mixed in a very confusing cocktail. Let&#8217;s start with the context part. A list, just as in Perl 5, it&#8217;s a series of items separated by commas. When assigning a list to something, the value will be different depending on the context:</p>
<pre class="brush: perl; light: true; title: ; notranslate">
my @array = 1, 2, 3; # list context assigns all the items
my $array = 1, 2, 3; # item context: assigns only the first item
</pre>
<p>List also flatten, so these two arrays are the same:</p>
<pre class="brush: perl; light: true; title: ; notranslate">
my @array1 = 1, 2, 3, 4;   # four elements
my @array2 = 1, 2, (3, 4); # also four elements
</pre>
<p>Because there are no references in Perl 6, if you want to have nested arrays, you have to explicitly ask for item context:</p>
<pre class="brush: perl; light: true; title: ; notranslate">
my @array2 = 1, 2, $(3, 4); # three elements
my @array2 = 1, 2, [3, 4];  # brackets also work. TIMTOWTDI
</pre>
<p>So far, sounds reasonable. But there is one problem: in addition to Lists, Perl 6 introduces another construct called <a href="http://doc.perl6.org/type/Parcel">parcels</a>, which stands for <em>Parenthesis Cells</em>. Just as lists, they can have elements separated by commas, but they behave differently: while Lists flatten, Parcels don&#8217;t. The fact that both constructs are dangerously similar, creates a lot of confusion.</p>
<pre class="brush: perl; light: true; title: ; notranslate">
my $a = 1, 2, 3, 4;       # $a is a single integer = 1.
my $b = (1, 2, 3, 4);     # $b is a parcel with 4 elements
my $c = ((1, 2), (3, 4)); # $c is a parcel with 2 elements

my @a = 1, 2, 3, 4;       # @a is an array with four elements
my @a = (1, 2, 3, 4);     # @b is also an array with 4 elements
my @a = ((1, 2), (3, 4)); # @c is also an array with 4 elements
</pre>
<p>How does Perl 6 know if a list of things surrounding by parenthesis and delimited by commas are lists or parcels? It depends of the context, in this case the sigil of the variable being assigned. Note that in the case of scalar context, the parenthesis surrounding the expression are fundamental to determine if the value assigned is a parcel or just the first element of the list. You might think the key to recognize parcels are the parenthesis, after all, they&#8217;re called <em>Parenthesis Cells</em> for a reason. But this is not the case. First, in list context parenthesis are pretty much ignored. And even in scalar context, some things can be parcels even if they don&#8217;t have parenthesis. For example the value returned by a function:</p>
<pre class="brush: perl; light: true; title: ; notranslate">
sub my_function { 1, 2, 3 }
my $a = my_function(); # $a is a parcel with three elements.
</pre>
<p>Sometimes it&#8217;s harder to determine if a list or a parcel is going to be used, because you don&#8217;t have a sigil to determine it. For example, when you do something like this:</p>
<pre class="brush: perl; light: true; title: ; notranslate">
((1, 2), (3, 4))[0] # returns 1 2
</pre>
<p>In this case Perl 6 assumes it&#8217;s a parcel, hence the items are not flattened. Same thing seems to happen when trying to call methods:</p>
<pre class="brush: perl; light: true; title: ; notranslate">
((1, 2), (3, 4)).elems # returns 2
</pre>
<p>However, sometimes it seems to take the value as a list:</p>
<pre class="brush: perl; light: true; title: ; notranslate">
((1, 2), (3, 4)).map({ say $_ }) # flattens and print four lines.
</pre>
<p>I don&#8217;t know how this is possible at all, since parcels don&#8217;t even have a <em>map</em> method. And I haven&#8217;t figured out how could Perl 6 interpret this as a list. I suspect this is either a bug or an exception hard coded in Rakudo (there are a few of those). Do you think that&#8217;s all? Of course not. Perl 6 has a third construct for comma separated items: <a href="http://doc.perl6.org/type/Capture">Captures</a>. These are used for function arguments. The rules for flattening Captures are variable, they depend on a <a href="http://doc.perl6.org/type/Signature">Signature</a> object associated with it. Each case is unique. I&#8217;m not going to describe how Captures work, they&#8217;re really complex. You can read the <a href="http://design.perl6.org/S06.html">documentation</a> if you&#8217;re curious.</p>
<h2>Conclusion</h2>
<p>Perl 6 is definitely an improvement over Perl 5 in many areas. It would require many posts to describe all the nice fixes in design. However, my feeling is that while some issues have been fixed, new quirks have been introduced. Of course, Perl 6 has not been released yet and some of these things might change. Also, I have not tried all the features to have a solid opinion on it. I think I&#8217;ll take a look again in a year when version 6.0.0 is out there.</p>
<h3>Update:</h3>
<p>Thanks to <a href="http://www.reddit.com/r/perl6/comments/2x10fq/perl_6_giving_with_one_hand_and_taking_with_the/">Reddit</a>, I just found out that most of the issues mentioned here about Perl 6 are going to be fixed. More specifically, the flattening of lists and the elimination of parcels. This is called The <a href="http://pmthium.com/2014/10/apw2014/">Great List Refactor</a> and it&#8217;s supposed to be there before the final release of the language.</p>
]]></content:encoded>
					
		
		
		
		<media:content url="https://2.gravatar.com/avatar/8446d2ad9b9d7eb75d269da1966fd480dda55da09158a64d1779445af3a58b5b?s=96&#38;d=https%3A%2F%2Fs0.wp.com%2Fi%2Fmu.gif&#38;r=G" medium="image">
			<media:title type="html">ceronman</media:title>
		</media:content>
	</item>
		<item>
		<title>A powerful unused feature of Python: function annotations.</title>
		<link>https://ceronman.com/2013/03/12/a-powerful-unused-feature-of-python-function-annotations/</link>
		
		<dc:creator><![CDATA[ceronman]]></dc:creator>
		<pubDate>Tue, 12 Mar 2013 16:13:15 +0000</pubDate>
				<category><![CDATA[Uncategorized]]></category>
		<guid isPermaLink="false">http://ceronman.com/?p=364</guid>

					<description><![CDATA[Something I&#8217;ve always missed when using Python (and dynamically typed languages in general) is nice tooling support. C# and Java have powerful IDEs that can improve your productivity significantly. Some people say that IDEs are a language smell. I disagree, IDEs are a truly valuable tool and the &#8220;nice language or IDE&#8221; statement is a false dilemma. &#8230; <a href="https://ceronman.com/2013/03/12/a-powerful-unused-feature-of-python-function-annotations/" class="more-link">Continue reading <span class="screen-reader-text">A powerful unused feature of Python: function&#160;annotations.</span> <span class="meta-nav">&#8594;</span></a>]]></description>
										<content:encoded><![CDATA[<p>Something I&#8217;ve always missed when using Python (and dynamically typed languages in general) is nice tooling support. C# and Java have powerful IDEs that can improve your productivity significantly. Some people say that <a href="http://www.recursivity.com/blog/2012/10/28/ides-are-a-language-smell/">IDEs are a language smell</a>. I disagree, IDEs are a truly valuable tool and the &#8220;nice language or IDE&#8221; statement is a <a href="http://en.wikipedia.org/wiki/False_dilemma">false dilemma</a>.</p>
<p>The problem with dynamically typed languages is that it&#8217;s impossible for the IDE to infer things about some parts of  your code. For example, if you start typing this:</p>
<pre class="brush: python; title: ; notranslate">
def myfunction(a, b):
...
</pre>
<p>It&#8217;s impossible for the editor to give you any hint about <code style="color:#770000;">a</code> or <code style="color:#770000;">b</code>.</p>
<p>I&#8217;ve been playing with <a href="http://www.dartlang.org/">Dart</a> and <a href="http://www.typescriptlang.org/">TypeScript</a> recently. These are languages that compile to Javascript and both try to improve tooling support. They&#8217;re interesting because, despite being dynamically typed languages, both implement optional type annotations. These have no different purpose than aiding editors and IDEs. Let me show you a simple example of how this can be seriously useful, consider the following Javascript code:</p>
<pre class="brush: jscript; title: ; notranslate">
function findTitle(title) {
	var titleElement = document.getElementById('title-' + title);
	return title;
}

var t = findTitle('mytitle');
t.innerHTML = 'New title';
</pre>
<p>The code has a small error that is not very easy to notice. Now let&#8217;s see the <a href="http://www.typescriptlang.org/Playground">TypeScript Web Editor</a> with the same code adding a single type annotation to <code style="color:#770000;">findTitle</code>:</p>
<p><a href="https://ceronman.com/wp-content/uploads/2013/03/typescript3.png"><img loading="lazy" data-attachment-id="391" data-permalink="https://ceronman.com/2013/03/12/a-powerful-unused-feature-of-python-function-annotations/typescript/" data-orig-file="https://ceronman.com/wp-content/uploads/2013/03/typescript3.png" data-orig-size="640,187" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;}" data-image-title="typescript" data-image-description="" data-image-caption="" data-medium-file="https://ceronman.com/wp-content/uploads/2013/03/typescript3.png?w=300" data-large-file="https://ceronman.com/wp-content/uploads/2013/03/typescript3.png?w=640" class="alignnone size-full wp-image-391" alt="typescript" src="https://ceronman.com/wp-content/uploads/2013/03/typescript3.png" width="590" height="172" srcset="https://ceronman.com/wp-content/uploads/2013/03/typescript3.png?w=590&amp;h=172 590w, https://ceronman.com/wp-content/uploads/2013/03/typescript3.png?w=150&amp;h=44 150w, https://ceronman.com/wp-content/uploads/2013/03/typescript3.png?w=300&amp;h=88 300w, https://ceronman.com/wp-content/uploads/2013/03/typescript3.png 640w" sizes="(max-width: 590px) 100vw, 590px" /></a></p>
<p>TypeScript found an error. By knowing that <code style="color:#770000;">title</code> is a <code style="color:#770000;">string</code>, it knows that <code style="color:#770000;">findTitle</code> is returning a <code style="color:#770000;">string</code> too, and therefore <code style="color:#770000;">t</code> is a <code style="color:#770000;">string</code> and strings don&#8217;t have an <code style="color:#770000;">innerHTML</code> method.</p>
<p>Early error detection is one advantage of good tooling support. Another interesting thing is accurate code completion. With good code completion you don&#8217;t have to browse huge API docs looking for what you need. You can discover the API while you type and use automatic re-factor tools without worrying about breaking code.</p>
<p><a href="https://ceronman.com/wp-content/uploads/2013/03/typescript-small.gif"><img loading="lazy" data-attachment-id="389" data-permalink="https://ceronman.com/2013/03/12/a-powerful-unused-feature-of-python-function-annotations/typescript-small/" data-orig-file="https://ceronman.com/wp-content/uploads/2013/03/typescript-small.gif" data-orig-size="640,240" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;}" data-image-title="typescript-small" data-image-description="" data-image-caption="" data-medium-file="https://ceronman.com/wp-content/uploads/2013/03/typescript-small.gif?w=300" data-large-file="https://ceronman.com/wp-content/uploads/2013/03/typescript-small.gif?w=640" class="alignnone size-full wp-image-389" alt="typescript-small" src="https://ceronman.com/wp-content/uploads/2013/03/typescript-small.gif" width="590" height="221" srcset="https://ceronman.com/wp-content/uploads/2013/03/typescript-small.gif?w=590&amp;h=221 590w, https://ceronman.com/wp-content/uploads/2013/03/typescript-small.gif?w=150&amp;h=56 150w, https://ceronman.com/wp-content/uploads/2013/03/typescript-small.gif?w=300&amp;h=113 300w, https://ceronman.com/wp-content/uploads/2013/03/typescript-small.gif 640w" sizes="(max-width: 590px) 100vw, 590px" /></a></p>
<p>Anders Hejlsberg&#8217;s <a href="http://channel9.msdn.com/posts/Anders-Hejlsberg-Introducing-TypeScript">introduction video</a> to TypeScript contains more interesting details about how annotations are really useful.</p>
<p>While playing with TypeScript I couldn&#8217;t stop thinking how cool would be to have something like that in Python. Then I realized that Python had syntax for annotations years before TypeScript or Dart were even planned. <a href="http://www.python.org/dev/peps/pep-3107/">PEP 3107</a> introduced function annotations in Python. Here is a small example:</p>
<pre class="brush: python; title: ; notranslate">
def greet(name: str, age: int) -&gt; str:
    print('Hello {0}, you are {1} years old'.format(name, age))
</pre>
<p>Here I annotated the <code style="color:#770000;">greet</code> function with the types of each argument and return value. Python annotations are completely optional and if you don&#8217;t do anything with them, they&#8217;re just ignored. However, with some little magic, it&#8217;s possible to tell python to check types at run-time:</p>
<pre class="brush: python; title: ; notranslate">
&gt;&gt;&gt; @typechecked
... def greet(name: str, age: int) -&gt; str:
...     print('Hello {0}, you are {1} years old'.format(name, age))
...
&gt;&gt;&gt; greet(1, 28)
Traceback (most recent call last):
    ...
TypeError: Incorrect type for &quot;name&quot;
</pre>
<p>Run-time type checking is not very useful though. However, a static analyzer could use that information to report errors as soon as you type. Also, IDEs and code completion libraries such as <a href="https://github.com/davidhalter/jedi">Jedi</a> could use that information to provide nice completion tips just like TypeScript does.</p>
<p>Some people might say that this makes the language too verbose. People using dynamic languages often want concise code. But in practice, if you take a look at any medium to large Python project or library, chances are that you&#8217;ll find something like this:</p>
<pre class="brush: python; title: ; notranslate">
def attach_volume(self, volume_id, instance_id, device):
    &quot;&quot;&quot;
    Attach an EBS volume to an EC2 instance.

    :type volume_id: str
    :param volume_id: The ID of the EBS volume to be attached.

    :type instance_id: str
    :param instance_id: The ID of the EC2 instance to which it will
                        be attached.

    :type device: str
    :param device: The device on the instance through which the
                   volume will be exposted (e.g. /dev/sdh)

    :rtype: bool
    :return: True if successful
    &quot;&quot;&quot;
    params = {'InstanceId': instance_id,
              'VolumeId': volume_id,
              'Device': device}
    return self.get_status('AttachVolume', params, verb='POST')
</pre>
<p>I took this code from the <a href="https://github.com/boto/boto">boto library</a>, they annotate functions using docstrings and <a href="http://sphinx-doc.org/">sphinx</a>. It&#8217;s a very common way of annotating public APIs. However, this method has some drawbacks: first, it&#8217;s really verbose and you repeat your self a lot writing code like this; second, it&#8217;s harder to parse because there are different docstring formats (sphinx, epydoc, pydoctor), so editors don&#8217;t bring code completion or early error checking; third, it&#8217;s very easy to make mistakes that unsync the docstrings and the code. In this particular example, if you ever run this function, you&#8217;ll notice that it returns a string, not a bool as the annotation suggests.</p>
<p><a href="https://developers.google.com/closure/">Google Closure</a> uses a similar docstring approach for type annotations in Javascript.</p>
<p>So, if people are already writing verbose docstrings to annotate functions, why not just use real function annotations? They&#8217;re completely optional and you don&#8217;t have to use them for non-public APIs or small scripts. They&#8217;re more concise, easier to process and easier to verify. Function annotations are only available on Python 3, you might say, but there are <a href="https://pypi.python.org/pypi/annotate/0.2.4">some</a> <a href="https://pypi.python.org/pypi/anodi/0.0.2">approaches</a> to emulate them in Python 2.x using decorators and it&#8217;s still way better than docstrings.</p>
<p>An interesting thing about Python annotations is that they don&#8217;t have to be types. In fact, you can use any Python expression as a function annotation. This opens the possibilities for a lot of interesting applications: typechecking, auto documentation, language bridges, object mappers, adaptation, design by contract, etc.</p>
<p>The <a href="https://github.com/kennknowles/python-typelanguage">typelanguage</a> library defines a whole language for communicating types. This language can be used with just string annotations. For example:</p>
<pre class="brush: python; title: ; notranslate">
def get_keys(a_dict: '{str: int}') -&gt; '[str]':
    ...
</pre>
<p>The downside of this flexibility is that it causes some confusion in the community about how annotations should be used. A recent <a href="http://mail.python.org/pipermail/python-ideas/2012-December/018088.html">discussion</a> in the Python-ideas mailing list unveiled this problem.</p>
<p>Personally, I would love to see this feature more used in the Python community. It has a lot of potential. I started a <a href="https://github.com/ceronman/typeannotations">small library to work with type annotations</a>. It implements the <code style="color:#770000;">typechecked</code> decorator described before, and some other useful things like structural interfaces, unions and logic predicates that can be used as function annotations. It&#8217;s still very immature, but I would like to improve it in the future by adding function overloading and other features. A detailed description of the library probably deserves a whole post for it. I would love to hack Jedi to add some basic support for auto-completion based on annotations.</p>
]]></content:encoded>
					
		
		
		
		<media:content url="https://2.gravatar.com/avatar/8446d2ad9b9d7eb75d269da1966fd480dda55da09158a64d1779445af3a58b5b?s=96&#38;d=https%3A%2F%2Fs0.wp.com%2Fi%2Fmu.gif&#38;r=G" medium="image">
			<media:title type="html">ceronman</media:title>
		</media:content>

		<media:content url="https://ceronman.com/wp-content/uploads/2013/03/typescript3.png" medium="image">
			<media:title type="html">typescript</media:title>
		</media:content>

		<media:content url="https://ceronman.com/wp-content/uploads/2013/03/typescript-small.gif" medium="image">
			<media:title type="html">typescript-small</media:title>
		</media:content>
	</item>
		<item>
		<title>Aaron Swartz</title>
		<link>https://ceronman.com/2013/02/25/aaron-swartz/</link>
		
		<dc:creator><![CDATA[ceronman]]></dc:creator>
		<pubDate>Mon, 25 Feb 2013 18:38:57 +0000</pubDate>
				<category><![CDATA[Uncategorized]]></category>
		<guid isPermaLink="false">http://ceronman.com/?p=347</guid>

					<description><![CDATA[Ha pasado ya más de un mes desde que Aaron Swartz falleció. Aaron fue un activista que dedicó gran parte de su vida a defender nuestros derechos. Su muerte fue verdaderamente lamentable. Quise hacer un pequeño tributo a Aaron. Decidí traducir y subtitular su emotiva conferencia sobre &#8220;How we stopped SOPA&#8221; en F2C 2012 : &#8230; <a href="https://ceronman.com/2013/02/25/aaron-swartz/" class="more-link">Continue reading <span class="screen-reader-text">Aaron Swartz</span> <span class="meta-nav">&#8594;</span></a>]]></description>
										<content:encoded><![CDATA[<p>Ha pasado ya más de un mes desde que <a href="http://es.wikipedia.org/wiki/Aaron_Swartz">Aaron Swartz</a> falleció. Aaron fue un activista que dedicó gran parte de su vida a defender <strong>nuestros</strong> derechos. Su muerte fue verdaderamente lamentable.</p>
<p>Quise hacer un pequeño tributo a Aaron. Decidí traducir y subtitular su emotiva conferencia sobre &#8220;How we stopped SOPA&#8221; en F2C 2012 :</p>
<p><div class="jetpack-video-wrapper"><iframe class="youtube-player" width="1100" height="619" src="https://www.youtube.com/embed/KARy7KIQmEY?version=3&#038;rel=1&#038;showsearch=0&#038;showinfo=1&#038;iv_load_policy=1&#038;fs=1&#038;hl=en&#038;autohide=2&#038;wmode=transparent" allowfullscreen="true" style="border:0;" sandbox="allow-scripts allow-same-origin allow-popups allow-presentation allow-popups-to-escape-sandbox"></iframe></div></p>
<p>La traducción la hice poco a poco en ratos libres. Si alguien encuentra cualquier error, por favor informen me.</p>
<p><a href="https://dl.dropbox.com/u/7008874/aaron/F2C2012%20Aaron%20Swartz%20keynote%20-%20How%20we%20stopped%20SOPA.srt">Aquí está la transcripción del inglés que también hice</a>.</p>
<p><a href="https://dl.dropbox.com/u/7008874/aaron/F2C2012%20Aaron%20Swartz%20keynote%20-%20How%20we%20stopped%20SOPA.es.srt">Aquí está el archivo de subtítulos en español.</a></p>
<p><a href="https://dl.dropbox.com/u/7008874/aaron/F2C2012%20Aaron%20Swartz%20keynote%20-%20How%20we%20stopped%20SOPA.mp4">Aquí está el vídeo original.</a></p>
]]></content:encoded>
					
		
		
		
		<media:content url="https://2.gravatar.com/avatar/8446d2ad9b9d7eb75d269da1966fd480dda55da09158a64d1779445af3a58b5b?s=96&#38;d=https%3A%2F%2Fs0.wp.com%2Fi%2Fmu.gif&#38;r=G" medium="image">
			<media:title type="html">ceronman</media:title>
		</media:content>
	</item>
		<item>
		<title>Ludum Dare 25</title>
		<link>https://ceronman.com/2012/12/23/ludum-dare-25/</link>
		
		<dc:creator><![CDATA[ceronman]]></dc:creator>
		<pubDate>Sun, 23 Dec 2012 05:38:17 +0000</pubDate>
				<category><![CDATA[Uncategorized]]></category>
		<guid isPermaLink="false">http://ceronman.com/?p=343</guid>

					<description><![CDATA[Last week  I participated in Ludum Dare, one of the most popular game making competitions out there. The idea is to write a game in 48 hours. You have to create everything in those 48 hours. That includes graphics, sounds and code. This time the theme was &#8220;you are the villian&#8221;. I tried to participate &#8230; <a href="https://ceronman.com/2012/12/23/ludum-dare-25/" class="more-link">Continue reading <span class="screen-reader-text">Ludum Dare 25</span> <span class="meta-nav">&#8594;</span></a>]]></description>
										<content:encoded><![CDATA[<p>Last week  I participated in <a href="http://www.ludumdare.com/compo/">Ludum Dare</a>, one of the most popular game making competitions out there. The idea is to write a game in 48 hours. You have to create <strong>everything</strong> in those 48 hours. That includes graphics, sounds and code. This time the theme was &#8220;you are the villian&#8221;. I tried to participate before but failed to finish something. This time my primary goal was to finish a game, even if it was very simple. I decided to write <a href="http://www.ludumdare.com/compo/ludum-dare-25/?action=preview&amp;uid=4896">something</a> between Space Invaders and Galaxian, where you actually played the aliens. I also decided to mix some tower defence elements. I had a lot of fun writing this game, even when in the end it was boring and buggy. Next time it will be better for sure.</p>
<p>For the game code I used <a href="http://www.dartlang.org/">Dart</a> and <a href="https://github.com/ceronman/dartcocos">a very immature library I&#8217;ve been working on</a>. The result wasn&#8217;t very good. The controls were poor and the game is not very fun. It also has some ugly bugs. Writing a game in 48 hours is really hard; more than I initially thought. I was new with these tools and that made everything harder too. For graphics I used <a href="http://www.dartlang.org/">The Gimp</a> and <a href="http://inkscape.org/">Inkscape</a>.</p>
<p>Here is a bit summary of my experience.</p>
<p><div class="jetpack-video-wrapper"><iframe class="youtube-player" width="560" height="315" src="https://www.youtube.com/embed/asrqx8KkBMI?version=3&#038;rel=1&#038;showsearch=0&#038;showinfo=1&#038;iv_load_policy=1&#038;fs=1&#038;hl=en&#038;autohide=2&#038;wmode=transparent" allowfullscreen="true" style="border:0;" sandbox="allow-scripts allow-same-origin allow-popups allow-presentation allow-popups-to-escape-sandbox"></iframe></div></p>
<p><strong>What went right:</strong></p>
<ul>
<li>I finished! That&#8217;s the best thing!</li>
<li>I made something <strong>simple</strong>.</li>
<li>I started using very simple graphics and decided to improve them later only if there was time.</li>
<li>I could come up with a design pretty quickly, this allowed me to spend more time on coding and creating graphics.</li>
<li>I created a simple plan and was able to follow it on time.</li>
</ul>
<p><strong>What went wrong</strong></p>
<ul>
<li>Game mechanics and controls. The controls didn&#8217;t fit quite right with the game. The game mechanics could have been improved.</li>
<li>No sound <img src="https://s0.wp.com/wp-content/mu-plugins/wpcom-smileys/twemoji/2/72x72/1f626.png" alt="😦" class="wp-smiley" style="height: 1em; max-height: 1em;" /> I didn&#8217;t have time for it.</li>
<li>Final game had some bugs because I tweaked the controls at the last minute.</li>
<li>I had bugs with other browsers that I didn&#8217;t detect until the last minute.</li>
<li>Sunday was significantly less productive than Saturday and Friday night. I was really tired and took a lot of breaks. Probably because I had a lot of work the previous week. I will try to take a rest before the compo next time.</li>
<li>I&#8217;m not an expert with the tools. That slowed me down with the code. And the engine I wrote is still very immature.</li>
</ul>
<p><strong>What I learned</strong></p>
<ul>
<li>Playing and rating games is equally or even more fun than writing the game. I love to see such explosion of creativity!</li>
<li>The community rocks! Thanks for everything.</li>
</ul>
<p>Ludum Dare was an incredible fun experience. I won&#8217;t miss the next one!</p>
]]></content:encoded>
					
		
		
		
		<media:content url="https://2.gravatar.com/avatar/8446d2ad9b9d7eb75d269da1966fd480dda55da09158a64d1779445af3a58b5b?s=96&#38;d=https%3A%2F%2Fs0.wp.com%2Fi%2Fmu.gif&#38;r=G" medium="image">
			<media:title type="html">ceronman</media:title>
		</media:content>
	</item>
		<item>
		<title>Beyond Javascript part 2: Dart and Typescript</title>
		<link>https://ceronman.com/2012/10/07/beyond-javascript-part-2-dart-and-typescript/</link>
		
		<dc:creator><![CDATA[ceronman]]></dc:creator>
		<pubDate>Mon, 08 Oct 2012 03:55:06 +0000</pubDate>
				<category><![CDATA[Uncategorized]]></category>
		<guid isPermaLink="false">http://ceronman.com/?p=340</guid>

					<description><![CDATA[I was glad to see the release of Microsoft TypeScript last week. After Google with Dart, it&#8217;s nice to see one more big player trying to create new languages for client side web development. I&#8217;ve been playing with Dart for a while and TypeScript really impressed me. In terms of syntax, I feel that TS &#8230; <a href="https://ceronman.com/2012/10/07/beyond-javascript-part-2-dart-and-typescript/" class="more-link">Continue reading <span class="screen-reader-text">Beyond Javascript part 2: Dart and&#160;Typescript</span> <span class="meta-nav">&#8594;</span></a>]]></description>
										<content:encoded><![CDATA[<p>I was glad to see the release of Microsoft TypeScript last week. After Google with Dart, it&#8217;s nice to see one more big player trying to create new languages for client side web development.</p>
<p>I&#8217;ve been playing with Dart for a while and TypeScript really impressed me. In terms of syntax, I feel that TS got some bits much better than Dart. Anders Hejlsberg has a true talent for language design. Some things I like about TypeScript:</p>
<ul>
<li>Full interoperability with the JavaScript world. This is both ways: from JS to TS and vice-versa. There is a huge ecosystem of code available for JS.</li>
<li>Better syntax. For example: type annotations are much more flexible, and they look nicer. Interfaces are better too, they cover all the cases and there is no need for ugly constructs such as &#8220;typedef&#8221; in Dart.</li>
<li>They offer support for private things, both in classes and modules. Although, this is only useful at compile time.</li>
<li>The web playground is really cool. It has auto completion, error highlighting and side by side compilation. It even has nice key bindings, almost like a good IDE.</li>
<li>The Visual Studio support and the online playground showed an amazing type inference engine. I have not seen that with Dart.</li>
<li>The module system looks better, it&#8217;s possible to explicitly importonly the things you need from a module. I like that.</li>
</ul>
<p>As a side note, I really like they way Microsoft is approaching open source with this project. They have open sourced a lot of things in the past, but this time it feels different. They used an Apache license, added a node.js package, Chrome and MongoDB were used in the demo. It shows a MS less afraid of interoperating with competing open source products and more interesting in truly participating in the community process.</p>
<p>Dart, on the other side, is a more ambitious project in my opinion. Although many of the cool promised features are not really there yet. For example: mirrors and tree shaking.</p>
<p>There are some things that I think Dart got better than TypeScript:</p>
<ul>
<li>It really fixes all the insanity of JavaScript: it has sane equality operators, real arrays, real hash maps, sane comparisons, sane scope, lexical &#8220;this&#8221; and many more things. TypeScript doesn&#8217;t fix any of these problems.</li>
<li>More features: operator overloading, string formatting, for-in loops, better collections, isolates, annotations, generics.</li>
<li>It improves the DOM interface. This is one of my favorite features.</li>
<li>Multiplatform IDE. Visual Studio is cool, but I don&#8217;t want to use Windows.</li>
</ul>
<p>Dart also provides a new VM. This is interesting because it allows optimizations based on type inference, direct debugging and other cool things. However, I think it&#8217;s very unlikely that other browsers ever implement the Dart VM. Dart2js will be the only option for a long time.</p>
<p>Another thing I like about Dart is how fast the project moves. Almost every week you see language changes and improvements for the IDE. I wonder if TypeScript is going to be as dynamic.</p>
<p>I&#8217;m currently working on a small personal project written in Dart. I would like to play with TypeScript but I don&#8217;t want to use Visual Studio. I think some traction is needed before support for other IDEs and editors appears. I guess I have to wait.</p>
]]></content:encoded>
					
		
		
		
		<media:content url="https://2.gravatar.com/avatar/8446d2ad9b9d7eb75d269da1966fd480dda55da09158a64d1779445af3a58b5b?s=96&#38;d=https%3A%2F%2Fs0.wp.com%2Fi%2Fmu.gif&#38;r=G" medium="image">
			<media:title type="html">ceronman</media:title>
		</media:content>
	</item>
		<item>
		<title>CoffeeScript: less typing, bad readability</title>
		<link>https://ceronman.com/2012/09/17/coffeescript-less-typing-bad-readability/</link>
		
		<dc:creator><![CDATA[ceronman]]></dc:creator>
		<pubDate>Mon, 17 Sep 2012 16:40:56 +0000</pubDate>
				<category><![CDATA[Uncategorized]]></category>
		<guid isPermaLink="false">http://ceronman.com/?p=298</guid>

					<description><![CDATA[I&#8217;ve used CoffeeScript for a few months now. Coming from Python, I felt that CoffeeScript was more concise than Javascript, so I decided to use it for a few small projects. Initially, it was a nice experience, but then I gradually realized that, while writing CoffeeScript code was very pleasant, reading it wasn&#8217;t so. I started to &#8230; <a href="https://ceronman.com/2012/09/17/coffeescript-less-typing-bad-readability/" class="more-link">Continue reading <span class="screen-reader-text">CoffeeScript: less typing, bad&#160;readability</span> <span class="meta-nav">&#8594;</span></a>]]></description>
										<content:encoded><![CDATA[<p>I&#8217;ve used CoffeeScript for a few months now. Coming from Python, I felt that CoffeeScript was more concise than Javascript, so I decided to use it for a few small projects. Initially, it was a nice experience, but then I gradually realized that, while writing CoffeeScript code was very pleasant, reading it wasn&#8217;t so. I started to notice that it was hard to read my own code a few months later. It was even harder to read other people&#8217;s code. I often found my self reading the translated JavaScript code to understand a line or two of CoffeeScript. I concluded that CoffeeScript was a language designed for writability at the cost of readability, easier to write, but harder to read.</p>
<p>The roots of CoffeeScript readability problems are two principles applied to the design of the language:</p>
<ul>
<li><em>Implicit is better than explicit</em></li>
<li><em>There is more than one way to do it</em></li>
</ul>
<h2>1. Implicit is better than explicit.</h2>
<p>Implicit or optional tokens in a programming language usually bring readability problems. For example, in C-like languages, you can omit curly brackets after a conditional expression if you only have one statement:</p>
<div class="highlight" style="background:#f0f3f3;">
<pre style="line-height:125%;"><span style="color:#006699;font-weight:bold;">if</span> (condition)
    action();</pre>
</div>
<p>But what happens if we add a new statement:</p>
<div class="highlight" style="background:#f0f3f3;">
<pre style="line-height:125%;"><span style="color:#006699;font-weight:bold;">if</span> (condition)
    action();
    action2();</pre>
</div>
<p>Now let&#8217;s take a look at a classic problem associated with implicit semicolon insertion in Javascript:</p>
<div class="highlight" style="background:#f0f3f3;">
<pre style="line-height:125%;"><span style="color:#006699;font-weight:bold;">function</span> foo() {
  <span style="color:#006699;font-weight:bold;">return</span>
    {
      foo<span style="color:#555555;">:</span> <span style="color:#ff6600;">1</span>
    }
}</pre>
</div>
<p>Both examples show cases where, at first glance, the code looks like it&#8217;s doing something, but after looking more carefully it&#8217;s doing something completely different. Even if you know the rules, it&#8217;s easy to fall into this trap if you&#8217;re an unwary reader. That&#8217;s a readability problem.</p>
<p>CoffeeScript introduces multiple implicit or optional tokens that create a lot of situations like these ones. And that&#8217;s something you can easily see in real code. For example, take this statement:</p>
<div class="highlight" style="background:#f0f3f3;">
<pre style="line-height:125%;">action(<span style="color:#006699;font-weight:bold;">true</span>, {
   <span style="color:#003333;">option1: </span><span style="color:#ff6600;">1</span>,
   <span style="color:#003333;">option2: </span><span style="color:#ff6600;">2</span>
})</pre>
</div>
<p>In CoffeeScript, you can omit the <strong>parenthesis</strong>, the <strong>curly brackets</strong> and the<strong> commas</strong>. They&#8217;re optional. So you can rewrite the statement above as this:</p>
<div class="highlight" style="background:#f0f3f3;">
<pre style="line-height:125%;">action <span style="color:#006699;font-weight:bold;">true</span>
   <span style="color:#003333;">option1: </span><span style="color:#ff6600;">1</span>
   <span style="color:#003333;">option2: </span><span style="color:#ff6600;">2</span></pre>
</div>
<h3>Problems with optional parenthesis</h3>
<p>Take a look at these two snippets. Next to the CoffeeScript code is the resulting JavaScript:</p>
<table style="width:100%;padding-top:10px;padding-bottom:10px;">
<tbody>
<tr>
<td class="highlight" style="background:#f0f3f3;width:50%;">
<pre style="line-height:125%;">doSomething <span style="color:#cc00ff;">() -&gt;</span>  <span style="color:#cc3300;">'hello'</span></pre>
</td>
<td class="highlight" style="background:#ddddf3;">
<pre style="line-height:125%;">doSomething(<span style="color:#006699;font-weight:bold;">function</span>() {
  <span style="color:#006699;font-weight:bold;">return</span> <span style="color:#cc3300;">'hello'</span>;
});</pre>
</td>
</tr>
<tr>
<td class="highlight" style="background:#f0f3f3;">
<pre style="line-height:125%;">doSomething<span style="color:#cc00ff;">() -&gt;</span>  <span style="color:#cc3300;">'hello'</span></pre>
</td>
<td class="highlight" style="background:#ddddf3;">
<pre style="line-height:125%;">doSomething()(<span style="color:#006699;font-weight:bold;">function</span>() {
  <span style="color:#006699;font-weight:bold;">return</span> <span style="color:#cc3300;">'hello'</span>;
});</pre>
</td>
</tr>
</tbody>
</table>
<p>Both statements do completely different different things, although they look very similar. The first one takes the space after the function name and applies implicit parenthesis to the function call, taking the function as a single parameter. The second one interprets the parenthesis as a function call with no arguments and applies implicit parenthesis on that result. Note that in CoffeeScript parenthesis are also optional in function definitions with no arguments. That means that the following two statements have exactly the same meaning:</p>
<div class="highlight" style="background:#f0f3f3;">
<pre style="line-height:125%;"><span style="color:#003333;">x = </span><span style="color:#555555;">-&gt;</span> <span style="color:#cc3300;">'result'</span>
<span style="color:#003333;">x = </span><span style="color:#cc00ff;">() -&gt;</span> <span style="color:#cc3300;">'result'</span></pre>
</div>
<p>Something curious about the rules used by CoffeeScript for implicit parenthesis is that the case for function calling is exactly the opposite of the case for function definition. In function calling you can omit parenthesis except when the function takes no arguments, whereas in function definition you can omit parenthesis only when the function has no arguments.</p>
<p>Now let&#8217;s take a look at some interesting case of how implicit parenthesis make things harder to read. This a small snippet taken directly from the CoffeeScript source code:</p>
<div class="highlight" style="background:#f0f3f3;">
<pre style="line-height:125%;"><span style="color:#003333;">action = </span><span style="color:#cc00ff;">(token, i) -&gt;</span>
      @tokens.splice i, <span style="color:#ff6600;">0</span>, @generate <span style="color:#cc3300;">'CALL_END'</span>, <span style="color:#cc3300;">')'</span>, token[<span style="color:#ff6600;">2</span>]</pre>
</div>
<p>The <strong>@tokens.splice</strong> function call has five elements separated by commas. At first glance you can think that the function is taking five arguments, but if you read carefully, you will notice that there is another function call as an argument: <strong>@generate.</strong> The last two arguments are for <strong>@generate</strong> not for <strong>@token.splice</strong>.  A more readable way of writing this would have been:</p>
<div class="highlight" style="background:#f0f3f3;">
<pre style="line-height:125%;"><span style="color:#003333;">action = </span><span style="color:#cc00ff;">(token, i) -&gt;</span>
      @tokens.splice i, <span style="color:#ff6600;">0</span>, @generate(<span style="color:#cc3300;">'CALL_END'</span>, <span style="color:#cc3300;">')'</span>, token[<span style="color:#ff6600;">2</span>])</pre>
</div>
<h3>Problems with optional commas</h3>
<p>In CoffeeScript you can omit commas for separating function arguments if you put them in a new line. For example the following two statements are equivalent:</p>
<div class="highlight" style="background:#f0f3f3;">
<pre style="line-height:125%;">moveTo <span style="color:#ff6600;">10</span>, <span style="color:#ff6600;">20</span>, <span style="color:#ff6600;">10</span>
moveTo <span style="color:#ff6600;">10</span>,
  <span style="color:#ff6600;">20</span>
  <span style="color:#ff6600;">10</span></pre>
</div>
<p>The comma after the first argument is mandatory, except if the next argument is an object definition:</p>
<div class="highlight" style="background:#f0f3f3;">
<pre style="line-height:125%;">moveTo(<span style="color:#ff6600;">10</span>, {<span style="color:#003333;">key: </span>value})

moveTo <span style="color:#ff6600;">10</span>
  <span style="color:#003333;">key: </span>value</pre>
</div>
<p>Also, if you&#8217;re not using explicit parenthesis, indentation is important, but not alignment, take a look at these examples with the resulting JavaScript next to them:</p>
<table style="width:100%;padding-top:10px;padding-bottom:10px;">
<tbody>
<tr>
<td class="highlight" style="background:#f0f3f3;width:50%;">
<pre style="line-height:125%;">doSomething <span style="color:#ff6600;">1</span>,
  <span style="color:#ff6600;">2</span>
  <span style="color:#ff6600;">3</span>
  <span style="color:#ff6600;">4</span></pre>
</td>
<td class="highlight" style="background:#ddddf3;">
<pre style="line-height:125%;">doSomething(<span style="color:#ff6600;">1</span>, <span style="color:#ff6600;">2</span>, <span style="color:#ff6600;">3</span>, <span style="color:#ff6600;">4</span>);</pre>
</td>
</tr>
<tr>
<td class="highlight" style="background:#f0f3f3;">
<pre style="line-height:125%;">doSomething <span style="color:#ff6600;">1</span>,
<span style="color:#ff6600;">2</span>
<span style="color:#ff6600;">3</span>
<span style="color:#ff6600;">4</span></pre>
</td>
<td class="highlight" style="background:#ddddf3;">
<pre style="line-height:125%;">doSomething(<span style="color:#ff6600;">1</span>, <span style="color:#ff6600;">2</span>);
<span style="color:#ff6600;">3</span>;
<span style="color:#ff6600;">4</span>;</pre>
</td>
</tr>
<tr>
<td class="highlight" style="background:#f0f3f3;">
<pre style="line-height:125%;">doSomething <span style="color:#ff6600;">1</span>,
  <span style="color:#ff6600;">2</span>
    <span style="color:#ff6600;">3</span>
   <span style="color:#ff6600;">4</span></pre>
</td>
<td class="highlight" style="background:#ddddf3;">
<pre style="line-height:125%;">doSomething(<span style="color:#ff6600;">1</span>, <span style="color:#ff6600;">2</span>, <span style="color:#ff6600;">3</span>, <span style="color:#ff6600;">4</span>);</pre>
</td>
</tr>
<tr>
<td class="highlight" style="background:#f0f3f3;">
<pre style="line-height:125%;">doSomething(<span style="color:#ff6600;">1</span>,
<span style="color:#ff6600;">2</span>
<span style="color:#ff6600;">3</span>
<span style="color:#ff6600;">4</span>)</pre>
</td>
<td class="highlight" style="background:#ddddf3;">
<pre style="line-height:125%;">doSomething(<span style="color:#ff6600;">1</span>, <span style="color:#ff6600;">2</span>, <span style="color:#ff6600;">3</span>, <span style="color:#ff6600;">4</span>);</pre>
</td>
</tr>
</tbody>
</table>
<p>You&#8217;re not safe from indentation problems if you use parenthesis, for example:</p>
<table style="width:100%;padding-top:10px;padding-bottom:10px;">
<tbody>
<tr>
<td class="highlight" style="background:#f0f3f3;width:50%;">
<pre style="line-height:125%;">doSomething (<span style="color:#555555;">-&gt;</span>
<span style="color:#cc3300;">'hello'</span>), <span style="color:#ff6600;">1</span></pre>
</td>
<td class="highlight" style="background:#ddddf3;">
<pre style="line-height:125%;">doSomething((<span style="color:#006699;font-weight:bold;">function</span>() {}, <span style="color:#cc3300;">'hello'</span>), <span style="color:#ff6600;">1</span>);</pre>
</td>
</tr>
<tr>
<td class="highlight" style="background:#f0f3f3;">
<pre style="line-height:125%;">doSomething (<span style="color:#555555;">-&gt;</span>
  <span style="color:#cc3300;">'hello'</span>), <span style="color:#ff6600;">1</span></pre>
</td>
<td class="highlight" style="background:#ddddf3;">
<pre style="line-height:125%;">doSomething((<span style="color:#006699;font-weight:bold;">function</span>() {
  <span style="color:#006699;font-weight:bold;">return</span> <span style="color:#cc3300;">'hello'</span>;
}), <span style="color:#ff6600;">1</span>);</pre>
</td>
</tr>
</tbody>
</table>
<p>In the first case, the line break after the function definition is replaced by an implicit comma, the parenthesis seem to be ignored.</p>
<h3>Problems with optional curly brackets</h3>
<p>Suppose that you have a function that takes two objects as arguments:</p>
<div class="highlight" style="background:#f0f3f3;">
<pre style="line-height:125%;">action({<span style="color:#003333;">key: </span>value}, {<span style="color:#003333;">option: </span>value}, otherValue)</pre>
</div>
<p>If you omit the curly brackets, you might think you get the same result:</p>
<div class="highlight" style="background:#f0f3f3;">
<pre style="line-height:125%;">action(<span style="color:#003333;">key: </span>value, <span style="color:#003333;">option: </span>value, otherValue)</pre>
</div>
<p>However, in this case CoffeeScript will take the first comma as a separator for object properties instead of a separator for arguments. The second comma however, it is taken as argument separator because it&#8217;s not an explicit key-value pair. The code will be translated to the following Javascript:</p>
<div class="highlight" style="background:#f0f3f3;">
<pre style="line-height:125%;">action({key<span style="color:#555555;">:</span> value, option<span style="color:#555555;">:</span> value}, otherValue);</pre>
</div>
<p>Something curious here is that in CoffeeScript, explicit key-value pairs are optional in object definitions, but only if you use explicit curly brackets. That means that you can write something like this:</p>
<table style="width:100%;padding-top:10px;padding-bottom:10px;">
<tbody>
<tr>
<td class="highlight" style="background:#f0f3f3;">
<pre style="line-height:125%;"><span style="color:#003333;">x = </span>{
  key1
  key2
  <span style="color:#003333;">key3: </span>value3
}</pre>
</td>
<td class="highlight" style="background:#ddddf3;">
<pre style="line-height:125%;">x <span style="color:#555555;">=</span> {
  key1<span style="color:#555555;">:</span> key1,
  key2<span style="color:#555555;">:</span> key2,
  key3<span style="color:#555555;">:</span> value3
};</pre>
</td>
</tr>
</tbody>
</table>
<h2>2. There is more than one way to do it (TIMTOWTDI)</h2>
<p>In CoffeeScript TIMTOWTDI is a strong principle. For example, instead of just having <strong>true</strong> and <strong>false</strong> keywords for boolean values, you can also have <strong>yes</strong> and <strong>no</strong>, <strong>off</strong> and <strong>on</strong>.</p>
<p>Also, you can write a simple conditional statement in multiple ways:</p>
<div class="highlight" style="background:#f0f3f3;">
<pre style="line-height:125%;"><span style="color:#003333;">x = </span><span style="color:#ff6600;">1</span> <span style="color:#006699;font-weight:bold;">if</span> y <span style="color:#555555;">!=</span> <span style="color:#ff6600;">0</span>

<span style="color:#006699;font-weight:bold;">if</span> y <span style="color:#555555;">!=</span> <span style="color:#ff6600;">0</span>
  <span style="color:#003333;">x = </span><span style="color:#ff6600;">1</span>

<span style="color:#003333;">x = </span><span style="color:#ff6600;">1</span> <span style="color:#006699;font-weight:bold;">unless</span> y <span style="color:#555555;">==</span> <span style="color:#ff6600;">0</span>

<span style="color:#006699;font-weight:bold;">unless</span> y <span style="color:#555555;">==</span> <span style="color:#ff6600;">0</span>
  <span style="color:#003333;">x = </span><span style="color:#ff6600;">1</span></pre>
</div>
<p>All the four statements above do exactly the same thing.</p>
<p>The problem with having multiple ways of doing one thing, is that the language end up with too many idioms. This makes code harder to read because a programmer trying to understand a piece of code must be familiar with all those idioms.</p>
<p>When we combine multiple idioms with implicit stuff and the fact that everything is an expression, the result is a bomb for readability. Here are a few examples taken directly from CoffeeScript&#8217;s source code.</p>
<h3>Fancy for loop</h3>
<div class="highlight" style="background:#f0f3f3;">
<pre style="line-height:125%;">  <span style="color:#006699;font-weight:bold;">break</span> <span style="color:#006699;font-weight:bold;">for</span> [tag], i <span style="color:#006699;font-weight:bold;">in</span> @tokens <span style="color:#006699;font-weight:bold;">when</span> tag <span style="color:#555555;">isnt</span> <span style="color:#cc3300;">'TERMINATOR'</span>
  @tokens.splice <span style="color:#ff6600;">0</span>, i <span style="color:#006699;font-weight:bold;">if</span> i</pre>
</div>
<p>This code deletes leading newlines from the list of tokens. The <strong>for</strong> loop is<br />
just a &#8220;cool&#8221; one liner to write this:</p>
<div class="highlight" style="background:#f0f3f3;">
<pre style="line-height:125%;">  <span style="color:#006699;font-weight:bold;">for</span> [tag], i <span style="color:#006699;font-weight:bold;">in</span> @tokens
    <span style="color:#006699;font-weight:bold;">if</span> tag <span style="color:#555555;">is</span> <span style="color:#cc3300;">'TERMINATOR'</span>
      <span style="color:#006699;font-weight:bold;">break</span></pre>
</div>
<h3>Tricky while</h3>
<div class="highlight" style="background:#f0f3f3;">
<pre style="line-height:125%;">i <span style="color:#555555;">+=</span> block.call <span style="color:#006699;font-weight:bold;">this</span>, token, i, tokens <span style="color:#006699;font-weight:bold;">while</span> <span style="color:#003333;">token = </span>tokens[i]</pre>
</div>
<p>In CoffeeScript everything is an expression. In the code above, is the <strong>while</strong><br />
expresion an argument of <strong>block.call</strong>? or is it acting as <strong>while</strong> for the<br />
whole statement? When we translate it to Javascript, this is what we get:</p>
<div class="highlight" style="background:#ddddf3;">
<pre style="line-height:125%;"><span style="color:#006699;font-weight:bold;">while</span> (token <span style="color:#555555;">=</span> tokens[i]) {
  i <span style="color:#555555;">+=</span> block.call(<span style="color:#006699;font-weight:bold;">this</span>, token, i, tokens);
}</pre>
</div>
<p>Much easier to read in my opinion. Also, note that the while expression is<br />
using an assignment operator instead of a comparision one. That adds 10 points<br />
to the readability bomb.</p>
<h3>Tricky if</h3>
<div class="highlight" style="background:#f0f3f3;">
<pre style="line-height:125%;">@detectEnd i <span style="color:#555555;">+</span> <span style="color:#ff6600;">1</span>, condition, action <span style="color:#006699;font-weight:bold;">if</span> token[<span style="color:#ff6600;">0</span>] <span style="color:#555555;">is</span> <span style="color:#cc3300;">'CALL_START'</span></pre>
</div>
<p>Here is a similar example, but this time, we&#8217;re using an <strong>if</strong> statement. As in<br />
the previous example, the <strong>if</strong> here is acting over the whole statement:</p>
<div class="highlight" style="background:#ddddf3;">
<pre style="line-height:125%;"><span style="color:#006699;font-weight:bold;">if</span> (token[<span style="color:#ff6600;">0</span>] <span style="color:#555555;">===</span> <span style="color:#cc3300;">'CALL_START'</span>) {
  <span style="color:#006699;font-weight:bold;">this</span>.detectEnd(i <span style="color:#555555;">+</span> <span style="color:#ff6600;">1</span>, condition, action);
}</pre>
</div>
<p>But what happens if we add an <strong>else</strong> to the <strong>if</strong>?</p>
<div class="highlight" style="background:#f0f3f3;">
<pre style="line-height:125%;">@detectEnd i <span style="color:#555555;">+</span> <span style="color:#ff6600;">1</span>, condition, action <span style="color:#006699;font-weight:bold;">if</span> token[<span style="color:#ff6600;">0</span>] <span style="color:#555555;">is</span> <span style="color:#cc3300;">'CALL_START'</span> <span style="color:#006699;font-weight:bold;">else</span> <span style="color:#006699;font-weight:bold;">false</span></pre>
</div>
<p>Now the <strong>if</strong> is assumed as an expression argument for the <strong>@detectEnd</strong> function:</p>
<div class="highlight" style="background:#ddddf3;">
<pre style="line-height:125%;"><span style="color:#006699;font-weight:bold;">this</span>.detectEnd(i <span style="color:#555555;">+</span> <span style="color:#ff6600;">1</span>, condition, action(token[<span style="color:#ff6600;">0</span>] <span style="color:#555555;">===</span> <span style="color:#cc3300;">'CALL_START'</span> <span style="color:#555555;">?</span> <span style="color:#006699;font-weight:bold;">void</span> <span style="color:#ff6600;">0</span> <span style="color:#555555;">:</span> <span style="color:#006699;font-weight:bold;">false</span>));</pre>
</div>
<h3>Fancy redefinition</h3>
<div class="highlight" style="background:#f0f3f3;">
<pre style="line-height:125%;">mainModule.moduleCache <span style="color:#555555;">and=</span> {}</pre>
</div>
<p>This code clears the module cache only if the value is not null (or something<br />
falsy). This could have been writen this way:</p>
<div class="highlight" style="background:#f0f3f3;">
<pre style="line-height:125%;"><span style="color:#006699;font-weight:bold;">if</span> mainModule.moduleCache
  <span style="color:#003333;">moduleCache = </span>{}</pre>
</div>
<p>But short and original code is much cooler. This is a good example of how TIMTOWTDI kills readability.</p>
<h3>Nested made flat</h3>
<div class="highlight" style="background:#f0f3f3;">
<pre style="line-height:125%;"><span style="color:#003333;">js = </span>(parser.parse lexer.tokenize code).compile options</pre>
</div>
<p>In this example we see how a nested chain of calls looks flat thanks to the<br />
magic of implicit parenthesis. The code translates to the following Javascript:</p>
<div class="highlight" style="background:#f0f3f3;">
<pre style="line-height:125%;">js <span style="color:#555555;">=</span> (parser.parse(lexer.tokenize(code))).compile(options);</pre>
</div>
<p>When the nested calls are explicit, the code becomes easier to read.</p>
<h2>Conclusion</h2>
<p>Of course readability is a very subjective topic. The problems described here might not apply to you if you come from a different background. I come from Python, C# and C++. But if you come from Ruby or Perl, you might think these are not problems but actually cool features.</p>
<p>I think that readability is more important than writability for a programming language. Code is usually written once, but read many times. Given that CoffeeScript doesn&#8217;t fix any of the fundamental problems of JavaScript, but damages readability, I decided not to use it anymore.</p>
<h2>Update:</h2>
<p>Another interesting post with some other readability problems in CoffeeScript: <a href="http://ryanflorence.com/2011/case-against-coffeescript/">http://ryanflorence.com/2011/case-against-coffeescript/</a></p>
]]></content:encoded>
					
		
		
		
		<media:content url="https://2.gravatar.com/avatar/8446d2ad9b9d7eb75d269da1966fd480dda55da09158a64d1779445af3a58b5b?s=96&#38;d=https%3A%2F%2Fs0.wp.com%2Fi%2Fmu.gif&#38;r=G" medium="image">
			<media:title type="html">ceronman</media:title>
		</media:content>
	</item>
		<item>
		<title>Beyond Javascript: Coffeescript</title>
		<link>https://ceronman.com/2012/08/20/beyond-javascript-coffeescript/</link>
		
		<dc:creator><![CDATA[ceronman]]></dc:creator>
		<pubDate>Mon, 20 Aug 2012 22:04:34 +0000</pubDate>
				<category><![CDATA[Uncategorized]]></category>
		<guid isPermaLink="false">http://ceronman.com/?p=292</guid>

					<description><![CDATA[During this year I&#8217;ve introduced my self into the world of front-end web development. I&#8217;ve never been a fan of the web as a development platform, but I have to admit that the web seems to be the unavoidable platform of the future. During my adventures with web development, I had to deal with Javascript, of course. &#8230; <a href="https://ceronman.com/2012/08/20/beyond-javascript-coffeescript/" class="more-link">Continue reading <span class="screen-reader-text">Beyond Javascript: Coffeescript</span> <span class="meta-nav">&#8594;</span></a>]]></description>
										<content:encoded><![CDATA[<p>During this year I&#8217;ve introduced my self into the world of front-end web development. <a href="https://ceronman.com/2010/02/03/la-web/">I&#8217;ve never been a fan of the web</a> as a development platform, but I have to admit that the web seems to be the unavoidable platform of the future. During my adventures with web development, I had to deal with Javascript, of course. My opinion about this language is not different from almost everyone else&#8217;s: It&#8217;s a language with good intentions which ended up being not so good. No wonder why is <a href="http://stackoverflow.com/questions/1995113/strangest-language-feature">the most &#8220;WTF&#8221; language</a> in Stack Overflow. After some months of continuously writing Javascript, I got used to it.</p>
<p>Parallel to my daily JS programming, I&#8217;ve been looking for alternatives. These come mostly in the form of languages that compile to Javascript. I decided to try <a href="http://coffeescript.org/">CoffeeScript</a> after watching a cool video titled <a href="http://vimeo.com/35258313">Better JS with CoffeeScript</a> by Sam Stephenson from <a href="http://37signals.com/">37signals</a>. CS is a nice little language inspired by Ruby, Python and others. I used CS for <a href="https://github.com/ceronman/coffeebf">some</a> <a href="https://github.com/ceronman/tinto">small</a> <a href="https://github.com/ceronman/arkatinto">toy</a> projects. It&#8217;s very cool and it has a strong community.</p>
<p>Probably the most striking feature of CoffeeScript is that it&#8217;s just Javascript. There is almost no semantic changes between them. The difference is purely aesthetic. This has some interesting advantages: 1. Debugging is not a problem because CS can be compiled to human readable JS. 2. CS can easily interoperate with any existent JS code.  The main disadvantage is that CS fixes none of the fundamental problems of JS.</p>
<p>I feel that writing CS is much better than writing JS. However, it took me a while to realize that reading CS is most of the time harder than reading JS. I realized this when reading my own code a few months later. My conclusion is that CoffeeScript&#8217;s design has a strong focus on writability, but not on readability. There are two factors that contribute to this in my opinion: 1. The design has a preference for implicit stuff. Some important tokens such as parenthesis, curly brackets, commas and others are optional. This leads to ambiguity in the code that must be resolved by precedence rules and creates code that is very hard to read.  2. The language adopts Perl&#8217;s motto: &#8220;<a href="http://en.wikipedia.org/wiki/There's_more_than_one_way_to_do_it">There&#8217;s more than one way to do it</a>&#8220;.  This ends up in code with too much different idioms, making things hard to read. I personally prefer Python&#8217;s motto: &#8220;<a href="http://www.python.org/dev/peps/pep-0020/">There should be one and preferably only one obvious way to do it</a>&#8220;.</p>
<p>A detailed description of all the readability problems in CoffeeScript deserves its own post. I&#8217;ll leave that for later. Meanwhile, I decided not to code in CS anymore. I don&#8217;t really see any value on it. I&#8217;ll go with plain Javascript when necessary, and I&#8217;m also exploring new alternatives such as <a href="http://www.dartlang.org/">Google Dart</a> and <a href="https://github.com/clojure/clojurescript">ClojureScript</a>.</p>
]]></content:encoded>
					
		
		
		
		<media:content url="https://2.gravatar.com/avatar/8446d2ad9b9d7eb75d269da1966fd480dda55da09158a64d1779445af3a58b5b?s=96&#38;d=https%3A%2F%2Fs0.wp.com%2Fi%2Fmu.gif&#38;r=G" medium="image">
			<media:title type="html">ceronman</media:title>
		</media:content>
	</item>
	</channel>
</rss>
