<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Mara&#39;s Blog</title>
    <link>https://blog.m-ou.se/</link>
    <description>Recent content on Mara&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Tue, 05 Dec 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.m-ou.se/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Behind the Scenes of Rust String Formatting: format_args!()</title>
      <link>https://blog.m-ou.se/format-args/</link>
      <pubDate>Tue, 05 Dec 2023 00:00:00 +0000</pubDate>
      
      <guid>https://blog.m-ou.se/format-args/</guid>
      <description>&lt;p&gt;The &lt;a href=&#34;https://doc.rust-lang.org/stable/std/fmt/struct.Arguments.html&#34;&gt;&lt;code&gt;fmt::Arguments&lt;/code&gt;&lt;/a&gt;
type is one of my favorite types in the Rust standard library.
It&amp;rsquo;s not particularly amazing, but it is a great building block that is indirectly used in nearly every Rust program.
This type, together with the &lt;a href=&#34;https://doc.rust-lang.org/stable/std/macro.format_args.html&#34;&gt;&lt;code&gt;format_args!()&lt;/code&gt; macro&lt;/a&gt;,
is the power behind &lt;code&gt;print!()&lt;/code&gt;, &lt;code&gt;format!()&lt;/code&gt;, &lt;code&gt;log::info!()&lt;/code&gt; and many more text formatting macros,
both from the standard library and community crates.&lt;/p&gt;
&lt;p&gt;In this blog post, we learn how it works, how it is implemented today, and how that might change in the future.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Rust Temporary Lifetimes and &#34;Super Let&#34;</title>
      <link>https://blog.m-ou.se/super-let/</link>
      <pubDate>Thu, 30 Nov 2023 00:00:00 +0000</pubDate>
      
      <guid>https://blog.m-ou.se/super-let/</guid>
      <description>&lt;p&gt;The lifetime of temporaries in Rust is a complicated but often ignored topic.
In simple cases, Rust keeps temporaries around for exactly long enough,
such that we don&amp;rsquo;t have to think about them.
However, there are plenty of cases were we might not get exactly what we want, right away.&lt;/p&gt;
&lt;p&gt;In this post, we (re)discover the rules for the lifetime of temporaries,
go over a few use cases for &lt;em&gt;temporary lifetime extension&lt;/em&gt;,
and explore a new language idea, &lt;code&gt;super let&lt;/code&gt;, to give us more control.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Do we need a &#34;Rust Standard&#34;?</title>
      <link>https://blog.m-ou.se/rust-standard/</link>
      <pubDate>Wed, 26 Oct 2022 00:00:00 +0000</pubDate>
      
      <guid>https://blog.m-ou.se/rust-standard/</guid>
      <description>&lt;p&gt;Languages like C and C++ are &lt;em&gt;standardized&lt;/em&gt;.
They are fully specified in an internationally recognized standards document.
Languages like Python, Swift and Rust do not have such a standards document.&lt;/p&gt;
&lt;p&gt;Should Rust be standardized? Why, or why not?
In this blog post, I try to explain why I do think we need an accurate &lt;em&gt;specification&lt;/em&gt;,
why I do &lt;em&gt;not&lt;/em&gt; think we need &amp;ldquo;standardization&amp;rdquo; (depending on your definition),
and give an overview of the current state of Rust&amp;rsquo;s stability and specification efforts.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Comparing Rust&#39;s and C&#43;&#43;&#39;s Concurrency Library</title>
      <link>https://blog.m-ou.se/rust-cpp-concurrency/</link>
      <pubDate>Tue, 16 Aug 2022 00:00:00 +0000</pubDate>
      
      <guid>https://blog.m-ou.se/rust-cpp-concurrency/</guid>
      <description>&lt;p&gt;The concurrency features that are included in the Rust standard library
are quite similar to what was available in C++11: threads, atomics, mutexes, condition variables, and so on.
In the past few years, however, C++ has gained quite a few new concurrency related
features as part C++17 and C++20, with more proposals still coming in for future versions.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s take some time to review C++ concurrency features,
discuss what their Rust equivalent could look like,
and what it&amp;rsquo;d take to get there.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Converting Integers to Floats Using Hyperfocus</title>
      <link>https://blog.m-ou.se/floats/</link>
      <pubDate>Tue, 10 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://blog.m-ou.se/floats/</guid>
      <description>&lt;p&gt;A few years ago, due to some random chain of events, I ended up implementing a conversion from 128 bit integers to 64 bit floats.
This would&amp;rsquo;ve turned out to be a complete waste of time,
except that my final version is faster than the builtin conversion of every compiler I tested.
In this blog post, I&amp;rsquo;ll explain what happened, how floats work, how this conversion works, and how it got a bit out of hand.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Rust is not a Company</title>
      <link>https://blog.m-ou.se/rust-is-not-a-company/</link>
      <pubDate>Fri, 18 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://blog.m-ou.se/rust-is-not-a-company/</guid>
      <description>&lt;p&gt;Last year, as an occasional contributor to the Rust project, I did not think
much about the organisational structure of the team behind the project. I saw a
hierarchy of teams and groups, team leaders, etc. Just like any other
organisation. This year, after getting more involved, becoming a library team
member and eventually team lead, I spent some more time thinking about &lt;em&gt;why&lt;/em&gt; we
have this structure, what these teams are for.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Writing Python inside your Rust code — Part 4</title>
      <link>https://blog.m-ou.se/writing-python-inside-rust-4/</link>
      <pubDate>Sun, 24 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.m-ou.se/writing-python-inside-rust-4/</guid>
      <description>&lt;p&gt;In this final part of the series,
we&amp;rsquo;ll explore a trick to make the behaviour of a macro depend
on whether it&amp;rsquo;s used as a statement or as part of an expression.
Using that, we&amp;rsquo;ll make the &lt;code&gt;python!{}&lt;/code&gt; macro
more flexible to allow saving, reusing, and inspecting Python variables.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Writing Python inside your Rust code — Part 3</title>
      <link>https://blog.m-ou.se/writing-python-inside-rust-3/</link>
      <pubDate>Sat, 09 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.m-ou.se/writing-python-inside-rust-3/</guid>
      <description>Have you ever seen the Rust compiler give a Python error? Or better, have you ever seen &lt;a href=&#34;https://rust-analyzer.github.io/&#34;&gt;rust-analyzer&lt;/a&gt; complain about Python syntax? In this post, we&amp;rsquo;ll extend our &lt;code&gt;python!{}&lt;/code&gt; macro to make that happen.</description>
    </item>
    
    <item>
      <title>Writing Python inside your Rust code — Part 2</title>
      <link>https://blog.m-ou.se/writing-python-inside-rust-2/</link>
      <pubDate>Sat, 25 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.m-ou.se/writing-python-inside-rust-2/</guid>
      <description>&lt;p&gt;In this part, we&amp;rsquo;ll extend our &lt;code&gt;python!{}&lt;/code&gt;-macro to be able to seamlessly
use Rust variables in the Python code within.
We explore a few options, and implement two alternatives.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Writing Python inside your Rust code — Part 1A</title>
      <link>https://blog.m-ou.se/writing-python-inside-rust-1a/</link>
      <pubDate>Sat, 18 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.m-ou.se/writing-python-inside-rust-1a/</guid>
      <description>&lt;p&gt;Before continuing to extend our &lt;code&gt;python!{}&lt;/code&gt; macro in &lt;em&gt;part 2&lt;/em&gt;,
let&amp;rsquo;s explore some things in more detail first.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Writing Python inside your Rust code — Part 1</title>
      <link>https://blog.m-ou.se/writing-python-inside-rust-1/</link>
      <pubDate>Fri, 17 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.m-ou.se/writing-python-inside-rust-1/</guid>
      <description>&lt;p&gt;About a year ago, I published a Rust crate called &lt;a href=&#34;https://crates.io/crates/inline-python&#34;&gt;inline-python&lt;/a&gt;,
which allows you to easily mix some Python into your Rust code using a &lt;code&gt;python!{ .. }&lt;/code&gt; macro.
In this series, I&amp;rsquo;ll go through the process of developing this crate from scratch.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Compile time unit arithmetic in C&#43;&#43;</title>
      <link>https://blog.m-ou.se/compile-time-unit-arithmetic/</link>
      <pubDate>Sun, 29 Sep 2013 18:00:00 +0000</pubDate>
      
      <guid>https://blog.m-ou.se/compile-time-unit-arithmetic/</guid>
      <description>&lt;p&gt;In &lt;a href=&#34;http://www.stroustrup.com/Software-for-infrastructure.pdf&#34;&gt;Software for Infrastructure&lt;/a&gt;,
Bjarne Stroustrup shows a way to use templates to make the C++ compiler
aware of the unit of a value (e.g. kilograms, seconds, etc.), such that it can check consistent use
and prevent disasters like the well known
&lt;a href=&#34;http://en.wikipedia.org/wiki/Mars_Climate_Orbiter#Cause_of_failure&#34;&gt;error at NASA in 1999&lt;/a&gt;
caused by mixing incompatible units.
In this article, I show how to extend this idea to support any number of base units and
linearly related units (e.g. centimetres, metres and inches) by teaching
the compiler how to do arithmetic on units.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43;11: Rvalue references for *this</title>
      <link>https://blog.m-ou.se/rvalue-references-for-this/</link>
      <pubDate>Sun, 21 Jul 2013 18:00:00 +0000</pubDate>
      
      <guid>https://blog.m-ou.se/rvalue-references-for-this/</guid>
      <description>&lt;p&gt;Recently, gcc added support rvalue references for &lt;code&gt;*this&lt;/code&gt;.
(Clang has supported it for quite a while now.)
In this post, I show how to use this feature, and how it means we can finally
define accessors and a few other things like &lt;code&gt;operator=&lt;/code&gt; correctly.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
