<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-US" xmlns:yt="http://www.youtube.com/xml/schemas/2015" xmlns:media="http://search.yahoo.com/mrss/">
  <title>tonsky.me</title>
  <subtitle>Nikita Prokopov’s blog</subtitle>
  <link type="application/atom+xml" href="https://tonsky.me/atom.xml" rel="self" />
  <link rel="alternate" type="text/html" href="https://tonsky.me/" />
  <id>https://tonsky.me/</id>
  <updated>2024-10-11T19:43:15Z</updated>
  <author>
    <name>Nikita Prokopov</name>
    <email>niki@tonsky.me</email>
  </author>
  <entry>
    <title>Podcast: Nikitonsky про современные редакторы кода @ Тысяча фичей</title>
    <link rel="alternate" type="text/html" href="https://tonsky.me/talks/#2024-09-30" />
    <id>https://tonsky.me/talks/#2024-09-30</id>
    <published>2024-09-30T00:00:00Z</published>
    <updated>2024-09-30T00:00:00Z</updated>
    <content type="html"><![CDATA[
<p><img src="https://tonsky.me/talks/covers/Тысяча фичей.png">    <audio controls="" preload="none">
      <source src="https://tonsky.me/talks/content/2024-09-30 Тысяча фичей.mp3" type="audio/mpeg">
    </audio>
</img></p>
<p>Каким должен быть редактор кода в 2024 году? Почему Vim морально устарел, а IDEA, кажется, сдает позиции? Популярность Zed, минимализм SublimeText, гибкость Emacs и многое другое в новом выпуске.</p>

]]></content>
    <author>
      <name>Nikita Prokopov</name>
      <email>niki@tonsky.me</email>
    </author>
  </entry>
  <entry>
    <title>Logo: Squint</title>
    <link rel="alternate" type="text/html" href="https://tonsky.me/design/#2024-07-squint" />
    <id>https://tonsky.me/design/#2024-07-squint</id>
    <published>2024-07-29T00:00:00Z</published>
    <updated>2024-07-29T00:00:00Z</updated>
    <content type="html"><![CDATA[
<img src="https://tonsky.me/design/images/2024-07-squint.svg" style="aspect-ratio: 420/140; " width="1000" height="333"><br>
<a href='https://github.com/squint-cljs/squint'>Squint</a> is a light-weight dialect of ClojureScript with a compiler and standard library. “The idea is that when you squint, it still looks like CLJS”.
]]></content>
    <author>
      <name>Nikita Prokopov</name>
      <email>niki@tonsky.me</email>
    </author>
  </entry>
  <entry>
    <title>Where Should Visual Programming Go?</title>
    <link rel="alternate" type="text/html" href="https://tonsky.me/blog/diagrams/" />
    <id>https://tonsky.me/blog/diagrams/</id>
    <published>2024-07-18T00:00:00Z</published>
    <updated>2024-10-11T19:43:15Z</updated>
    <summary type="html"><![CDATA[
Visual programming and textual code should co-exist next to each other, not replace one another
]]></summary>
    <content type="html"><![CDATA[
<p>There’s a wonderful article by Sebastian Bensusan: “<a href="https://blog.sbensu.com/posts/demand-for-visual-programming/">We need visual programming. No, not like that.</a>” (the dot is part of the title ¯\_(ツ)_/¯).</p>
<p>In it, Sebastian argues that we shouldn’t try to replace all code with visual programming but instead only add graphics where it makes sense:</p>
<blockquote>
  <p>Most visual programming environments fail to get any usage. Why? They try to replace code syntax and business logic but developers never try to visualize that. Instead, developers visualize state transitions, memory layouts, or network requests.</p>
  <p>In my opinion, those working on visual programming would be more likely to succeed if they started with aspects of software that developers already visualize.</p>
</blockquote>
<p>I love diagrams myself! Whenever I encounter a complicated task and try to solve it in code, it always gets messy. But after drawing a diagram, my understanding improves, and the code gets cleaner. Win-win!</p>
<p>Here’s one I made for button states in Humble UI:</p>
<figure>
<img src="https://tonsky.me/blog/diagrams/button.webp"></figure>
<p>I bet you thought buttons are easy? Me too, at first. But after certain threshold your head just can’t fit all the states and transitions.</p>
<p>Or for an image upload component:</p>
<figure>
<img src="https://tonsky.me/blog/diagrams/image_upload.webp"></figure>
<p>Again: it would’ve been easy if not for error handling. But with a principled approach, you can get through any of that.</p>
<p>Sebastian gives many more examples of useful visualizations in his article, too.</p>
<p>But now, how does all this relate to code? I think there’re four levels.</p>
<h1 id="level-0-diagrams-live-separately">Level 0: Diagrams live separately</h1>
<p>You draw them in a separate tool, then use that to help you write code. Maybe put them on a wiki for other people to see. The point is: the diagram lives completely separate from the code.</p>
<p>Downsides: hard to discover, can get out of date.</p>
<p>This is what I did in the two examples above, and I guess what most of us can do given modern tools. But hey—it’s still not that bad!</p>
<h1 id="level-1-diagrams-live-next-to-code">Level 1: Diagrams live next to code</h1>
<p>One simple trick would solve the problem of discovery: what if we could put images into our text files?</p>
<p>Currently, the best you can do is this:</p>
<pre><code>                   +-----+  --&gt;
                   | N_4 |------     &lt;--- +-----+
                   +-----+     |    |-----| R_3 |
                      |    15  |    | 5   +-----+
                      |50      |    |        |
    +-----+  ---&gt;     |        +-----+       | 70
    | N_2 |------     |        | N_3 |       |
    +-----+     |     |        +-----+       |
     |       15 |     |            | 30      |
     | 10       |   +-----+  &lt;---  |         |
  @  |          ----|  S  |--------|         |
  @  |       &lt;@@@   +-----+                  |
  V  |                 |   |                 |
     |              10 |   |                 |
  +-----+              |   V                 |
  | R_2 |          +-----+                   |
  +-----+          |  E  |                   |
|  |               +-----+                   |
|  | 40             |  |                     |
V  |             10 |  |                     |
   |    +-----+     |  V                     |
   -----| R_1 |-----|                        |
        +-----+                              |
           |     ---&gt;         +-----+        |
           |------------------|  D  |---------
                   10         +-----+</code></pre>
<p>But it gets messy real quick. What if we could do this instead?</p>
<figure>
<img src="https://tonsky.me/blog/diagrams/sublime.webp"></figure>
<p>Upsides: easy to implement (once everybody agrees on <em>how</em> to do that), universal (probably many other use cases).</p>
<p>Downsides: still can get out of date. “Comments are not code”—the same applies here.</p>
<p>Oh, and if you are coding in a terminal, this party is not for you. Sorry. We are thinking about the future here.</p>
<h1 id="level-2-diagrams-are-generated-from-code">Level 2: Diagrams are generated from code</h1>
<p>This is what Sebastian was hinting at. Code and diagrams co-exist, one is generated from the other.</p>
<p>Generating diagrams from code is definitely something IDEs can do:</p>
<figure>
<img src="https://tonsky.me/blog/diagrams/autogenerated.webp"></figure>
<p>Upsides:</p>
<ul>
  <li>Always up to date.</li>
  <li>Non-invasive: can be integrated into IDE without affecting how code is stored.</li>
</ul>
<p>Downsides:</p>
<ul>
  <li>It can help you understand, but can it help you think?</li>
  <li>Probably not very visually appealing, as these things tend to be. It’s hard to automatically lay out a good diagram.</li>
</ul>
<h1 id="level-3-diagrams-are-code">Level 3: Diagrams are code</h1>
<p>This is what the endgame should be IMO. Some things are better represented as text. Some are best understood visually. We should mix and match what works best on a case-by-case basis. Don’t try to visualize simple code. Don’t try to write code where a diagram is better.</p>
<p>One of the attempts was Luna. They tried dual representation: everything is code <em>and</em> diagram at the same time, and you can switch between the two:</p>
<figure>
<img src="https://tonsky.me/blog/diagrams/luna.webp"><figcaption>From <a href="https://web.archive.org/web/20160730111343/http://www.luna-lang.org/">luna-lang.org</a></figcaption></figure>
<p>But this way, you are not only getting benefits of both ways, you are also constrained by both text <em>and</em> visual media at the same time. You can’t do stuff that’s hard to visualize (loops, recursions, abstractions) AND you can’t do stuff that’s hard to code.</p>
<p>No, I think textual coding should stay textual where it works, BUT we should also be able to jump into a diagram tool, draw a state machine there and execute it the same way we execute text code.</p>
<figure>
<img src="https://tonsky.me/blog/diagrams/new_file@2x.png"></figure>
<p>And when I mean draw, I mean draw. With direct manipulation, all that jazz. And <em>without</em> converting it back to text.</p>
<p>So what I’m saying is: diagrams should not replace or “augment” text. They should be just another tool that lives <em>next</em> to the text. But a tool on its own.</p>
<p>Think of it as a game engine like Godot or Unity. In them, you can write normal text code, but you can <em>also</em> create and edit scenes. These scenes are stored in their own files, have specialized editors that know how to edit them, and have no code representation. Because why? The visual way <em>in this particular case</em> is better.</p>
<figure>
<img src="https://tonsky.me/blog/diagrams/godot.jpg"></figure>
<p>So the challenge here is not about integrating diagrams, but to think about which types of diagrams can be useful, can work better than code, and be directly executed.</p>
<h1 id="non-goal-diagrams-replace-code">Non-goal: Diagrams replace code</h1>
<p>Important note: we are not talking about doing code graphically. This is just a less convenient way of doing things that text already does.</p>
<figure>
<img src="https://tonsky.me/blog/diagrams/blockly.webp"></figure>
<p>We are also not talking about no-code platforms: sometimes code is just better.</p>
<p>But until this bright future arrives, put a diagram or two on the wiki. Your teammates will thank you for that.</p>

]]></content>
    <author>
      <name>Nikita Prokopov</name>
      <email>niki@tonsky.me</email>
    </author>
  </entry>
  <entry>
    <title>Clojure macros continue to surprise me</title>
    <link rel="alternate" type="text/html" href="https://tonsky.me/blog/clojure-macros/" />
    <id>https://tonsky.me/blog/clojure-macros/</id>
    <published>2024-07-15T00:00:00Z</published>
    <updated>2024-10-11T19:43:15Z</updated>
    <content type="html"><![CDATA[
<p>Clojure macros have two modes: avoid them at all costs/do very basic stuff, or go absolutely crazy.</p>
<p>Here’s the problem: I’m working on <a href="https://github.com/HumbleUI/HumbleUI">Humble UI’s</a> component library, and I wanted to document it. While at it, I figured it could serve as an integration test as well—since I showcase every possible option, why not test it at the same time?</p>
<p>This is what I came up with: I write component code, and in the application, I show a table with the running code on the left and the source on the right:</p>
<figure>
<img src="https://tonsky.me/blog/clojure-macros/before@2x.png"></figure>
<p>It was important that code that I show is exactly the same code that I run (otherwise it wouldn’t be a very good test). Like a quine: hey program! Show us your source code!</p>
<p>Simple with Clojure macros, right? Indeed:</p>
<pre><code>(defmacro table [&amp; examples]
  (list &#x27;ui/grid {:cols 2}
    (for [[_ code] (partition 2 examples)]
      (list &#x27;list
        code (pr-str code)))))</code></pre>
<p>This macro accepts code AST and emits a pair of AST (basically a no-op) back and a string that we serialize that AST to.</p>
<p>This is what I consider to be a “normal” macro usage. Nothing fancy, just another day at the office.</p>
<p>Unfortunately, this approach reformats code: while in the macro, all we have is an already parsed AST (data structures only, no whitespaces) and we have to pretty-print it from scratch, adding indents and newlines.</p>
<p>I tried a couple of existing formatters (clojure.pprint, zprint, cljfmt) but wasn’t happy with any of them. The problem is tricky—sometimes a vector is just a vector, but sometimes it’s a UI component and shows the structure of the UI.</p>
<p>And then I realized that I was thinking inside the box all the time. We already have the perfect formatting—it’s in the source file!</p>
<p>So what if... No, no, it’s too brittle. We shouldn’t even think about it... But what if...</p>
<p>What if our macro read the source file?</p>
<p>Like, actually went to the file system, opened a file, and read its content? We already have the file name conveniently stored in <code>*file*</code>, and luckily Clojure keeps sources around.</p>
<p>So this is what I ended up with:</p>
<pre><code>(defn slurp-source [file key]
  (let [content      (slurp (io/resource file))
        key-str      (pr-str key)
        idx          (str/index-of content key)
        content-tail (subs content (+ idx (count key-str)))
        reader       (clojure.lang.LineNumberingPushbackReader.
                       (java.io.StringReader.
                         content-tail))
        indent       (re-find #&quot;\s+&quot; content-tail)
        [_ form-str] (read+string reader)]
    (-&gt;&gt; form-str
      str/split-lines
      (map #(if (str/starts-with? % indent)
              (subs % (count indent))
              %)))))</code></pre>
<p>Go to a file. Find the string we are interested in. Read the first form after it <em>as a string</em>. Remove common indentation. Render. As a string.</p>
<p>Voilà!</p>
<figure>
<img src="https://tonsky.me/blog/clojure-macros/after@2x.png"></figure>
<p>I know it’s bad. I know you shouldn’t do it. I know. I know.</p>
<p>But still. Clojure is the most fun I have ever had with any language. It lets you play with code like never before. Do the craziest, stupidest things. Read the source file of the code you are evaluating? <a href="https://github.com/tonsky/remote-require/">Fetch code from the internet and splice it into the currently running program?</a></p>
<p>In any other language, this would’ve been a project. You’d need a parser, a build step... Here—just ten lines of code, on vanilla language, no tooling or setup required.</p>
<p>Sometimes, a crazy thing is exactly what you need.</p>

]]></content>
    <author>
      <name>Nikita Prokopov</name>
      <email>niki@tonsky.me</email>
    </author>
  </entry>
  <entry>
    <title>Local, first, forever</title>
    <link rel="alternate" type="text/html" href="https://tonsky.me/blog/crdt-filesync/" />
    <id>https://tonsky.me/blog/crdt-filesync/</id>
    <published>2024-06-24T00:00:00Z</published>
    <updated>2024-10-11T19:43:15Z</updated>
    <summary type="html"><![CDATA[
We explore how to build local-first sync on top of simple file storage
]]></summary>
    <content type="html"><![CDATA[
<img src="https://tonsky.me/blog/crdt-filesync/cover.webp"><p>So I was at the <a href="https://www.localfirstconf.com/">Local-First Conf</a> the other day, listening to <a href="https://www.youtube.com/watch?v=NMq0vncHJvU">Martin Kleppmann</a>, and this slide caught my attention:</p>
<figure>
<img src="https://tonsky.me/blog/crdt-filesync/talk.webp"></figure>
<p>Specifically, this part:</p>
<figure>
<img src="https://tonsky.me/blog/crdt-filesync/talk2.webp"></figure>
<p>But first, some context.</p>
<h1 id="what-is-local-first">What is local-first?</h1>
<p>For the long version, go <a href="https://www.inkandswitch.com/local-first/">to Ink &amp; Switch, who coined the term</a>. Or listen for Peter van Hardenberg <a href="https://www.localfirst.fm/1">explaining it on LocalFirst.fm</a>.</p>
<p>Here’s my short version:</p>
<ul>
  <li>It’s software.</li>
  <li>That prefers keeping your data local.</li>
  <li>But it still goes to the internet occasionally to sync with other users, fetch data, back up, etc.</li>
</ul>
<p>If it doesn’t go to the internet at all, it’s just local software.</p>
<p>If it doesn’t work offline with data it already has, then it’s just normal cloud software. You all know the type — sorry, Dave, I can’t play the song I just downloaded because your internet disappeared for one second...</p>
<p>But somewhere in the middle — local-first. We love it because it’s good for the end user, you and me, not for the corporations that produce it.</p>
<h1 id="whats-the-problem-with-local-first">What’s the problem with local-first?</h1>
<p>The goal of local-first software is to get control back into the hands of the user, right? You own the data (literally, it’s on your device), yada-yada-yada. That part works great.</p>
<p>However, local-first software still has this online component. For example, personal local-first software still needs to sync between your own devices. And syncing doesn’t work without a server...</p>
<p>So here we have a problem: somebody writes local-first software. Everybody who bought it can use it until the heat death of the universe. They <em>own</em> it.</p>
<p>But if the company goes out of business, syncing will stop working. And companies go out of business all the time.</p>
<figure>
<img src="https://tonsky.me/blog/crdt-filesync/bonto.webp"></figure>
<p>What do we do?</p>
<h1 id="cue-dropbox">Cue Dropbox</h1>
<p>The solution is to use something widely available that will probably outlive our company. We need something popular, accessible to everyone,  has multiple implementations, and can serve as a sync server.</p>
<p>And what’s the most common end-user application of cloud sync?</p>
<p>Dropbox! Well, not necessarily Dropbox, but any cloud-based file-syncing solution. iCloud Drive, OneDrive, Google Drive, <a href="https://tonsky.me/blog/syncthing/">Syncthing</a>, etc.</p>
<p>It’s perfect — many people already have it. There are multiple implementations, so if Microsoft or Apple go out of business, people can always switch to alternatives. File syncing is a commodity.</p>
<p>But file syncing is a “dumb” protocol. You can’t “hook” into sync events, or update notifications, or conflict resolution. There isn’t much API; you just save files and they get synced. In case of conflict, best case, you get two files. Worst — you get only one :)</p>
<p>This simplicity has an upside and a downside. The upside is: if you can work with that, it would work everywhere. That’s the interoperability part from Martin’s talk.</p>
<p>The downside is: you can’t do much with it, and it probably won’t be optimal. But will it be enough?</p>
<h1 id="version-1-super-naive">Version 1: Super-naive</h1>
<p>Let’s just save our state in a file and let Dropbox sync it (in my case, I’m using Syncthing, but it’s the same idea. From now on, I’ll use “Dropbox” as a common noun).</p>
<p>Simple:</p>
<figure>
<img src="https://tonsky.me/blog/crdt-filesync/naive.webp"></figure>
<p>But what happens if you change the state on two machines? Well, you get a conflict file:</p>
<figure>
<img src="https://tonsky.me/blog/crdt-filesync/naive_conflict.webp"></figure>
<p>Normally, it would’ve been a problem. But it’s not if you are using CRDT!</p>
<blockquote>
  <p>CRDT is a collection of data types that all share a very nice property: they can always be merged. It’s not always the perfect merge, and not everything can be made into a CRDT, but IF you can put your data into a CRDT, you can be sure: all merges will go without conflicts.</p>
</blockquote>
<p>With CRDT, we can solve conflicts by opening both files, merging states, and saving back to <code>state.xml</code>. Simple!</p>
<p>Even in this form, Dropbox as a common sync layer works! There are some downsides, though:</p>
<ul>
  <li>conflicting file names are different between providers,</li>
  <li>some providers might not handle conflicts at all,</li>
  <li>it needs state-based CRDT.</li>
</ul>
<h1 id="version-2-a-file-per-client">Version 2: A file per client</h1>
<p>The only way to avoid conflicts is to always edit locally. So let’s give each client its own file!</p>
<figure>
<img src="https://tonsky.me/blog/crdt-filesync/file_per_client.webp"></figure>
<p>Now we just watch when files from other clients get changed and merge them with our own.</p>
<p>And because each file is only edited on one machine, Dropbox will not report any conflicts. Any conflicts inside the data will be resolved by us via CRDT magic.</p>
<h1 id="version-3-operations-based">Version 3: Operations-based</h1>
<p>What if your CRDT is operation-based? Meaning, it’s easier to send operations around, not the whole state?</p>
<p>You can always write operations into a separate append-only file. Again, each client only writes to its own, so no conflicts on the Dropbox level:</p>
<figure>
<img src="https://tonsky.me/blog/crdt-filesync/ops.webp"></figure>
<p>Now, the operations log can grow quite long, and we can’t count on Dropbox to reliably and efficiently sync only parts of the file that were updated.</p>
<p>In that case, we split operations into chunks. Less work for Dropbox to sync and less for us to catch up:</p>
<figure>
<img src="https://tonsky.me/blog/crdt-filesync/ops_batches.webp"></figure>
<p>You can, of course, save the position in the file to only apply operations you haven’t seen. Basic stuff.</p>
<p>Theoretically, you should be able to do operational transformations this way, too.</p>
<h1 id="demo">Demo</h1>
<p>A very simple proof-of-concept demo is at <a href="https://github.com/tonsky/crdt-filesync">github.com/tonsky/crdt-filesync</a>.</p>
<p>Here’s a video of it in action:</p>
<figure>
  <video autoplay="" muted="" loop="" preload="auto" playsinline="" controls="">
    <source src="https://tonsky.me/blog/crdt-filesync/demo.mp4" type="video/mp4">
  </video>
</figure>
<p>Under the hood, it uses Automerge for merging text edits. So it’s a proper CRDT, not just two files merging text diffs.</p>
<h1 id="conclusion">Conclusion</h1>
<p>If you set out to build a local-first application that users have complete control and ownership over, you need something to solve data sync.</p>
<p>Dropbox and other file-sync services, while very basic, offer enough to implement it in a simple but working way.</p>
<p>Sure, it won’t be as real-time as a custom solution, but it’s still better for casual syncs. Think Apple Photos: only your own photos, not real-time, but you know they will be everywhere by the end of the day. And that’s good enough!</p>
<p>Imagine if Obsidian Sync was just “put your files in the folder” and it would give you conflict-free sync? For free? Forever? Just bring your own cloud?</p>
<p>I’d say it sounds pretty good.</p>

]]></content>
    <author>
      <name>Nikita Prokopov</name>
      <email>niki@tonsky.me</email>
    </author>
  </entry>
</feed>
